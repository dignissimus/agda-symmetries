% !TEX program = lualatex 

\documentclass[9pt]{beamer}

\usetheme{metropolis}
\usepackage{bookmark}
\usepackage{xcolor-solarized}

\setbeamercolor{normal text}{%
  fg=solarized-base02,
  bg=solarized-base3!20!white
}
\setbeamercolor{alerted text}{%
  fg=solarized-red
}
\setbeamercolor{example text}{%
  fg=solarized-green
}
\setbeamercolor{frametitle}{%
    fg=solarized-blue!70!black,
    bg=solarized-base2
}

\setbeamerfont{title}{series=\bfseries,parent=structure}
\setbeamerfont{frametitle}{series=\bfseries,parent=structure}

\usecolortheme{orchid}

\usepackage{hott}
\usepackage{mathtools}
\usepackage{macros}
\usepackage[final]{microtype}

\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{lipsum}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{mathrsfs}
\usepackage{braket}
\usepackage{quiver}
\usepackage{mathtools}
\usepackage{commath}
\usepackage{xparse}
\usepackage{array}
\usepackage{subcaption} %side by side diagrams
\usepackage{floatrow}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{babel}% added

% bibliography
\usepackage[style=authortitle,backend=biber]{biblatex}
\addbibresource{symmetries.bib}

% fancy boxes
\usepackage[most]{tcolorbox}

\newtcolorbox{qblock}[1][Question]{
  colback=white,
  colframe=solarized-orange,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}
\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\newtcolorbox{pblock}[1][Proposition]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\newtcolorbox{tblock}[1][Theorem]{
  colback=white,
  colframe=solarized-green,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\usepackage{tikz}
\usetikzlibrary{cd}
\usetikzlibrary{fit}

\usepackage{fontspec}
\setmonofont{Iosevka}[
    Path=./Iosevka/,
    Extension = .ttf,
    UprightFont=*-Regular,
    BoldFont=*-Bold,
    ItalicFont=*-Italic,
    BoldItalicFont=*-BoldItalic
]

%Information to be included in the title page:
\title{On commutativity, total orders, and sorting}
\author[shortname]{
  Wind Wong \inst{1}
  \and Vikraman Choudhury \inst{2}
  \and Simon J. Gay \inst{1}
}
\institute[shortinst]{\inst{1} University of Glasgow \and %
                      \inst{2} Universit\`{a} di Bologna and OLAS Team, INRIA}
\date{February 14, 2024}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Motivation}

  \begin{qblock}
    What is a correct sorting algorithm?
  \end{qblock}

  \begin{itemize}
    \item We learn sorting algorithms in undergraduate ordinateur science.

    \item A sorting algorithm is a \inline{sort : List Nat -> List Nat} function.

    \item For example, \inline{sort([3,1,6,5])} produces \inline{[1,3,5,6]}.

    \item Why is it correct?

          \begin{itemize}
            \item In ordered lists, elements are accessed in order by their indices.

            \item The in-order access matches the ordering on numbers:
                  \[
                  l(0) \leq l(1) \leq l_{3}(2) \leq l_{4}
                  \]

            \item Or, any two consecutive pairs of elements are ordered:
                  \[
                  l(0) \leq l(1), l(1) \leq l(3), l(0) \leq l(2) \ldots
                  \]
            \item What determines correctness of sorting? We need to study them abstractly!
          \end{itemize}
    \item The type \inline{sort : List Nat -> List Nat} is very imprecise, can we give it a more precise type?
  \end{itemize}
\end{frame}

\begin{frame}{Motivation}

  We will need some background, and use some technology:

\begin{itemize}

  \item We will study algebraic structures, using a framework for \alert{universal algebra}, that we have developed in type theory. Using this framework, we define free algebras and their universal properties.

  \item We study two specific algebraic structures: \alert{monoids} and \alert{commutative monoids}, which are crucial to sorting, and the corresponding constructions of \alert{free monoids} and \alert{free commutative monoids}.

  \item Using this framework, we will formally define:
    \begin{itemize}
        \item What is a sorting algorithm?
        \item When is a sorting algorithm correct?
    \end{itemize}

  \item We will show that these correctness criteria are complete, by connecting them to the theory of \alert{total orders}. This gives us an \alert{axiomatics of sorting}.

  \item These ideas come from category theory and universal properties. We work in univalent type theory (in particular, \alert{Cubical Agda}), which gives us powerful tools to implement these ideas correctly, and compute with them.
  
  %% gives us higher inductive types, which allows us to reason with
  %% commutativity and equations of algebras. (No setoid hell!)

\end{itemize}

\end{frame}

\begin{frame}{Homotopy Type Theory}
\frametitle{Homotopy Type Theory}

Homotopy Type Theory (HoTT) is an extension of intensional MLTT.
%% and allows us to reason with equivalences more powerfully.

\begin{itemize}

  \item Function extensionality: $\forall x. \, f(x) = g(x) \rightarrow f = g$)

  \item Quotient types: $Q = A / R$ (via higher inductive types)

  \item Homotopy types: contractible types, propositions, sets, groupoids, 2-groupoids, \ldots

  \item Richer notion of equality types (or identity types or Path types)

  \item and many more \ldots

\end{itemize}

\end{frame}

\begin{frame}{Function Extensionality}
\frametitle{Homotopy Type Theory}

Function extensionality: $\forall x. \, f(x) = g(x) \rightarrow f = g$

\begin{itemize}

  \item MLTT by itself does not have function extensionality

  \item It has to be added as an axiom (we lose \alert{canonicity}!)

  \item<2-> funExt can be derived as a theorem in HoTT

\end{itemize}

\end{frame}

\begin{frame}{Quotient Types}
\frametitle{Homotopy Type Theory}

Quotient Types:

\begin{itemize}

  \item In MLTT we can only emulate quotient types with setoids
  \item We need to prove functions are setoid homomorphisms when defining a function
  \item A lot of proof obligation (\alert{setoid hell}!)
  \item<2-> HoTT lets us define quotient types directly with HITs

\end{itemize}

\end{frame}

\begin{frame}{Mere Proposition}
\frametitle{Homotopy Type Theory}

Mere Proposition:

\begin{itemize}

  \item In MLTT we don't have a distinction between sets and propositions (both are types)
  \item We might end up needing a \alert{stronger theorem} to prove a proposition
  \item E.g. existential proofs are done with $\Sigma$-types, requiring us to \alert{construct} the element
  \item<2-> HoTT allows us to have types that are "\alert{mere propositions}"
  \item<2-> E.g. existential proofs can be done with propositionally truncated $\Sigma$-types (mere existence)
  \item<2-> We can use mere existential proofs to prove other propositions even \alert{without} having the specific element

\end{itemize}

\end{frame}

\begin{frame}{Equalities between Types}
\frametitle{Homotopy Type Theory}
Equalities between types:

\begin{itemize}

  \item In MLTT we don't have equalities between types
  \item HoTT gives us equalities between types by the \alert{univalence axiom}
  \item E.g. given $A, B : \mathcal{U}, P : \mathcal{U} \rightarrow \mathcal{U}, A = B$,
        we can get $P(B)$ from $P(A)$ by transport (substitution)

\end{itemize}

\uncover<2->{
\begin{dblock}
  Given types $A$ and $B$, $A$ is equivalent to $B$ ($A \simeq B$) if there exists an
  equivalence $A \rightarrow B$.
  A function $f$ is said to be an equivalence if
  $\left( \sum_{g :B \rightarrow A} (f \circ g \sim \mathrm{id}_B) \right) \times \left( \sum_{g:B \rightarrow A} (g \circ f \sim \mathrm{id}_A) \right)$.
\end{dblock}

\begin{tblock}[Univalence axiom]
  $(A = B) \simeq (A \simeq B)$
\end{tblock}
}

\end{frame}

\begin{frame}{Equalities between Types}
\frametitle{Homotopy Type Theory}

\begin{tblock}[Univalence axiom]
  $(A = B) \simeq (A \simeq B)$
\end{tblock}

Consider $\mathbb{B}$, there are \alert{two} $\mathbb{B} = \mathbb{B}$:

We have two equivalences:
\begin{itemize}
    \item $\text{id} := \lambda \{ \text{true} \mapsto \text{true}, \text{false} \mapsto \text{false} \}$
    \item $\text{not} := \lambda \{ \text{true} \mapsto \text{false}, \text{false} \mapsto \text{true} \}$
\end{itemize}

Univalence gives us two $\mathbb{B} = \mathbb{B}$ generated from \alert{id} and \alert{not},
but these two equalities are not equal!

\end{frame}

\begin{frame}{Homotopy Levels}
\frametitle{Homotopy Levels}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  \\
  % & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}

\begin{frame}{Contractible Types}
\frametitle{Homotopy Levels}

H-Level 0: Contractible types

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
\end{align*}

There exists a \alert{center of contraction} such that all elements of $A$ are equal to
the center of contraction.

Examples:
\begin{itemize}
  \item $\mathbf{1}$ (Unit type)
\end{itemize}

All contractible types are equivalent to $\mathbf{1}$!

\end{frame}

\begin{frame}{Propositional Types}
\frametitle{Homotopy Levels}

H-Level 1: Mere propositions

\begin{align*}
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
\end{align*}

All elements of $A$ are equal to each other.

Examples:
\begin{itemize}
  \item $\mathbf{1}$ (Unit type)
  \item $\mathbf{0}$ (Void type)
\end{itemize}

All h-propositions are equivalent to either $\mathbf{1}$ or $\mathbf{0}$.

A type that represents a proposition should be an $\mathsf{hProp}$.

E.g. mere existential proofs can be done with a truncated $\Sigma$-type.
($\Sigma$-type wrapped in a HIT that makes all its elements equal.)

\end{frame}

\begin{frame}{Sets}
\frametitle{Homotopy Levels}

H-Level 2: Sets

\begin{align*}
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
\end{align*}

The identity type of $A$ is a proposition.
All elements of $x = x$ are equal.

Examples:
\begin{itemize}
  \item $\mathbf{1}$, $\mathbf{0}$
  \item $\mathbb{N}$
  \item $\mathbb{B}$
  \item $\mathsf{hProp}$ ($\sum_{A : \mathcal{U}} \text{isProp}(A)$)
\end{itemize}

For the scope of the project, this is primarily what we are working with!

\end{frame}

\begin{frame}[fragile]
\frametitle{Homotopy Levels}

H-Level 2: Sets

\begin{align*}
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
\end{align*}

In a type theory with \alert{K-axiom} / \alert{uniqueness of identity proof} (UIP), all types
are h-sets.

E.g. Idris2 lets us prove UIP by pattern matching:

    \begin{dblock}[UIP]
        \begin{code}
uip : (A : Type) -> (x, y : A) -> (p, q : x = y) -> p = q
uip A x x Refl Refl = Refl
        \end{code}
    \end{dblock}

We can embed extensional type theory into HoTT with h-sets.

\end{frame}


\begin{frame}{Groupoids}
\frametitle{Homotopy Levels}

H-Level 3: Groupoids

\begin{align*}
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
\end{align*}

The identity type of $A$ is a set.

Examples:
\begin{itemize}
  \item Any type that satisfies $\text{isSet}$...
  \item Type of all sets: $\mathsf{hSet}$ ($\sum_{A : \mathcal{U}} \text{isSet}(A)$)
  \item Type of types that are equal to Bool: $\dsum*{X:\UU}{\Trunc{X = \Bool}}$
  \item Circle: $S^1$
\end{itemize}

Consider $\mathbb{B} : \mathsf{hSet}$, univalence gives us two $\mathbb{B} = \mathbb{B}$
generated by \alert{id} and \alert{not}.

These two equalities are not equal!

\end{frame}

\begin{frame}{Homotopy Levels}
\frametitle{Homotopy Levels}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  \\
  % & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}


\begin{frame}[fragile]{Higher Inductive Types}
\frametitle{Higher Inductive Types}

\begin{code}
-- ordered lists
data List (A : Type) : Type where
  nil : List A
  _::_ : A -> List A -> List A

-- swap lists or unordered lists or finite multisets
data SList (A : Type) : Type where
  []    : SList A
  _::_  : (x : A) -> (xs : SList A) -> SList A
  swap  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (SList A)
  -- alternatively
  -- trunc : (x y : SList A) -> (p q : x == y) -> p == q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}
\begin{code}
data SList (A : Type) : Type where
  []    : SList A
  _::_  : (x : A) -> (xs : SList A) -> SList A
  swap  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (SList A)

_++_ : ∀ (xs ys : FMSet A) → FMSet A
[] ++ ys = ys
(x :: xs) ++ ys = x :: xs ++ ys
swap x y xs i ++ ys =
  -- proof x :: y :: (xs ++ ys) ≡ y :: x :: (xs ++ ys)
trunc xs zs p q i j ++ ys =
  -- proof cong (_++ ys) p ≡ cong (_++ ys) q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}
\begin{code}
-- Set quotient
data _/_ (A : Type) (R : A → A → Type) : Type where
  [_] : (a : A) → A / R
  q/ : (a b : A) → (r : R a b) → [ a ] ≡ [ b ]
  squash/ : (x y : A / R) → (p q : x ≡ y) → p ≡ q

data Perm {A : Type} : List A -> List A -> Type where
  perm-refl : ∀ {xs} -> Perm xs xs
  perm-swap : ∀ {x y xs ys zs}
    -> Perm (xs ++ x ∷ y ∷ ys) zs
    -> Perm (xs ++ y ∷ x ∷ ys) zs

-- Swap list as quotient
PList : Type -> Type
PList A = List A / Perm
\end{code}

\end{frame}

\begin{frame}
\frametitle{Cubical Type Theory}

\begin{itemize}

  \item The project is formalized in \alert{Cubical Agda}, an implementation of Cubical Type Theory
  \item Cubical Type Theory is a variant of HoTT that doesn't lose \alert{computational properties} of type theory
        (no axioms, has \alert{canonicity})
  \item Univalence is not an axiom, it is provable, and it computes!
  \item Designed to preserve \alert{canonicity}, using univalence won't destroy computational content of a proof

\end{itemize}


\end{frame}

\begin{frame}{Universal Algebra}
\frametitle{Universal Algebra}

A \alert{signature} $\sigma$ is:
\begin{itemize}
    \item a set of \alert{operation symbols} $op : \mathsf{hSet}$
    \item an \alert{arity function} $ar : \sigma \rightarrow \mathsf{hSet}$
\end{itemize}

This gives a signature endofunctor $F_{\sigma}(X) := \sum_{f : op} X^{ar(f)}$

A $\sigma$-structure is a $F_{\sigma}$-algebra:
\begin{itemize}
    \item a \alert{carrier set} $X : hSet$
    \item an \alert{interpretation function}: $\alpha_X\colon\Sig(X) \to X$
\end{itemize}

A $\sigma$-algebra homomorphism $h: A \rightarrow B$ is a function such that \\
for all $(\sigma, a_1, \dots, a_n) : F_{\sigma}(X)$:
\begin{align*}
    h(\alpha_A(\sigma, a_1, \dots, a_n)) = \alpha_B(\sigma, h(a_1), \dots, h(a_n))
\end{align*}

$F_{\sigma}$-algebras and their morphisms form a category $\sigma$-Alg.

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}
Example: $\mathbb{N}$ as a \alert{monoid}

The signature $\sigma_{\mathsf{Mon}}$ has:
\begin{itemize}
    \item the set of \alert{operation symbols} $op : \mathsf{hSet} = \{\munit, \mmult\}$ (or $\Fin[2]$ or $\Bool$)
    \item the \alert{arity function} $ar : \sigma \rightarrow \mathsf{hSet} = \{\munit \mapsto \Void,, \mmult \mapsto \Bool\}$
\end{itemize}

The algebra has the carrier set $\Nat$ and the interpretation function:

\begin{align*}
\alpha(\munit) & = 0 \\
\alpha(\mmult, a, b) & = a + b 
\end{align*} 


\end{frame}


\begin{frame}{Free Object}
\frametitle{Free Objects}

The forgetful functor $\sigma$-Alg to $Set$ admits a left adjoint

This gives us a free $\sigma$-algebra construction on a carrier set

\begin{dblock}[The universal property of a free object]
For any object \( \mathfrak{Y} \) in $\sigma$-Alg, $U(\blank) \circ \eta$ is a equivalence:

% https://q.uiver.app/#q=WzAsMyxbMCwwLCJYIl0sWzIsMCwiVShBKSJdLFsyLDIsIlUoQikiXSxbMCwxLCJpIiwwLHsiY29sb3VyIjpbMSwxMDAsNjBdfSxbMSwxMDAsNjAsMV1dLFswLDIsImciLDJdLFsxLDIsIlUoZikiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XV0=
\[
\begin{tikzcd}[ampersand replacement=\&]
	F(X) \\
	\\
	\mathfrak{Y}
	\arrow["f", dotted, from=1-1, to=3-1]
\end{tikzcd}
\hspace{1cm}
\begin{tikzcd}[ampersand replacement=\&]
	X \&\& {U(F(X))} \\
	\\
	\&\& {U(\mathfrak{Y})}
	\arrow["\eta", color={rgb,255:red,255;green,54;blue,51}, from=1-1, to=1-3]
	\arrow["g"', from=1-1, to=3-3]
	\arrow["{U(f)}", dotted, from=1-3, to=3-3]
\end{tikzcd}\]

where $U$ is the forgetful functor and $\eta : X \rightarrow F(X)$ is the canonical injection.
\end{dblock}

\end{frame}

\begin{frame}
\frametitle{Free Objects}

We can construct a a free $\sigma$-algebra on $V$ as an inductive type $Tr_\sigma(V)$:
\begin{itemize}
    \item $\text{leaf} : V \rightarrow Tr_\sigma(V)$
    \item $\text{node} : \sum_f(Tr_\sigma(V)^{ar(f)}) \rightarrow Tr_\sigma(V)$
\end{itemize}

\only<1>{
\vspace{1cm}
\adjustbox{scale=1,center}{%
% https://q.uiver.app/#q=WzAsMixbMCw0XSxbMCwwLCJlIl0sWzAsMSwiIiwyLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\begin{tikzcd}[ampersand replacement=\&,cramped]
	e \\
	\\
	\\
	\\
	{ e }
	\arrow[no head, from=5-1, to=1-1]
\end{tikzcd}

\hspace{10mm}

% https://q.uiver.app/#q=WzAsNCxbMiwyLCJcXG11bml0Il0sWzAsMCwieF8xIl0sWzIsNCwiXFxidWxsZXQiXSxbNCwwLCJ4XzIiXSxbMSwwLCIiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsMl0sWzAsM11d
\begin{tikzcd}[ampersand replacement=\&,cramped, column sep=tiny, row sep=normal]
	{x_1} \&\&\&\& {x_2} \\
	\\
	\&\& \mmult \\
	\\
	\&\& { x_1 \mmult x_2 }
	\arrow[no head, from=1-1, to=3-3]
	\arrow[no head, from=3-3, to=5-3]
	\arrow[no head, from=3-3, to=1-5]
\end{tikzcd}

\hspace{10mm}

% https://q.uiver.app/#q=WzAsNixbMiwyLCJcXG11bml0Il0sWzMsMSwiXFxtdW5pdCJdLFsyLDAsInhfMSJdLFs0LDAsInhfMiJdLFswLDAsImUiXSxbMiw0LCJlIFxcbXVuaXQgKHhfMSBcXG11bml0IHhfMikiXSxbMCwxLCIiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzIsMSwiIiwyLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFszLDEsIiIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNCwwLCIiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzUsMCwiIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\begin{tikzcd}[ampersand replacement=\&,cramped, column sep=tiny, row sep=normal]
	\munit \&\& {x_1} \&\& {x_2} \\
	\&\&\& \mmult \\
	\&\& \mmult \\
	\\
	\&\& { \munit \mmult (x_1 \mmult x_2) }
	\arrow[no head, from=3-3, to=2-4]
	\arrow[no head, from=1-3, to=2-4]
	\arrow[no head, from=1-5, to=2-4]
	\arrow[no head, from=1-1, to=3-3]
	\arrow[no head, from=5-3, to=3-3]
\end{tikzcd}
}

}

\only<2>{

node is our \alert{interpretation function} $\alpha : F_\sigma(Tr_\sigma(V)) \rightarrow Tr_\sigma(V)$

leaf is our \alert{canonical injection} $\eta : V \rightarrow Tr_\sigma(V)$

This forms a $\sigma$-algebra $\str{T}(V) = (\tree{V}, \term{node})$

By the \alert{universal property}: $(\blank) \comp \eta \colon \sigAlg(\str{T}(V),\str{X}) \xto{\sim} (V \to X)$

The inverse to the equivalence: the \alert{extension operation} $\ext{(\blank)}$,
maps $f\colon V \to X$ to a homomorphism $\ext{f}\colon \str{T}(V) \to \str{X}$

In functional programming (recursion schemes), $\ext{(\blank)}$ is a \alert{fold}/\alert{catamorphism}.
}
\end{frame}

\begin{frame}
\frametitle{Universal Algebra}

An \alert{equation signature} $\epsilon$ is defined by:
\begin{itemize}
    \item A set of \alert{equation symbols} $eq : Set$
    \item an \alert{arity function} for free variables $fv : eq \to Set$
\end{itemize}

We define a system of equation (or a \alert{theory} $T$) with pairs of trees on the set of free variables:
$l, r : (e : eq) \to Tr_\sigma(fv(e))$

$\mathfrak{X}$ satisfies $T$ ($\mathfrak{X} \entails T$) if for all $e : eq$ and $\rho : fv(e) \to X$,
$\ext{\rho}(l(e)) = \ext{\rho}(r(e))$

Concretely:
\begin{itemize}
    \item $\rho : fv(e) \to X$ maps free variables in equations to elements of $X$
    \item $\ext{\rho} : Tr_\sigma(fv(e)) \to X$ evaluates a tree given some variables
\end{itemize}

Because $\ext{\rho}$ is a \alert{homomorphism}, it must evaluate the tree correctly!

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}
Example: $\mathbb{N}$ as a \alert{monoid}

The equation signature $\sigma_{\mathsf{Mon}}$ has:
\begin{itemize}
    \item the set of \alert{equation symbols} $op : \mathsf{hSet} = \{\text{unitl}, \text{unitr}, \text{assocr}\}$
    (or $\Fin[3]$)
    \item the \alert{arity function}
    $fv : \sigma \rightarrow \mathsf{hSet} = \{\text{unitl} \mapsto \mathbf{1}, \text{unitr} \mapsto \mathbf{1}, \text{assocr} \mapsto \mathbf{3}\}$
\end{itemize}

To show $(\Nat,+) \entails \text{Mon}$:
\begin{align*}
unitl  & : \forall \rho. \, \rho(0) + \munit = \rho(0) \\
unitr  & : \forall \rho. \, \munit + \rho(0) = \rho(0) \\
assocr & : \forall \rho. \, (\rho(0) + \rho(1)) + \rho(2) = \rho(0) + (\rho(1) + \rho(2))
\end{align*} 


\end{frame}

\begin{frame}[fragile]{Constructions of free monoids}
    \begin{dblock}[Cons Lists]
        \begin{code}
data List (A : UU) : UU where
  nil : List A
  _cons_ : A -> List A -> List A
        \end{code}
    \end{dblock}
    
    \alert{Example:} \inline{3 cons 1 cons 2 cons nil}
    
    \begin{dblock}[Array]
        $\type{Array}(A) = \dsum{n\colon\Nat}{f : \Fin[n] \to A}$
    \end{dblock}

    \alert{Example:} $(3, \lambda\{ 0 \mapsto 3 ; 1 \mapsto 1 ; 2 \mapsto 2 \})$
    
    Each construction satisfies the universal property of free monoids.
\end{frame}

\begin{frame}[fragile]{Constructions of free monoids}
    \begin{dblock}[Cons Lists]
        \begin{code}
data List (A : UU) : UU where
  nil : List A
  _cons_ : A -> List A -> List A
        \end{code}
    \end{dblock}
We define the $\ext{(\blank)}$ on $f : A \to X$:
\begin{align*}
    \ext{f}([]) & = e \\
    \ext{f}(x :: xs) & =  f(x) + \ext{f}(xs)
\end{align*} 
Then we prove:
\begin{itemize}
    \item $\ext{f}$ is a \alert{homomorphism} $\text{List}(A) \to \mathfrak{X}$
    \item $\ext{(\blank)}$ and $(\blank) \circ [\_]$ are \alert{inverse} of each other.
\end{itemize}

List satisfies the \alert{universal property} of free monoid. Therefore, List is a free monoid!

\end{frame}

\begin{frame}[fragile]{Constructions of free monoids}
    \begin{dblock}[Array]
        $\type{Array}(A) = \dsum{n\colon\Nat}{f : \Fin[n] \to A}$
    \end{dblock}

The monoid operation:
\begin{align*}
    (n , f) \mmult (m , g) & = (n + m , f \oplus g) \\
    (f \oplus g)(o) & = \begin{cases}
      f(o), & \text{if}\ o < n \\
      g(o - n), & \text{otherwise}
    \end{cases}
\end{align*} 

We define the $\ext{(\blank)}$ on $f : A \to X$:
\begin{align*}
    \ext{f}(0 , g) & = e \\
    \ext{f}(S(n) , g) & = f(g(0)) + \ext{f}(n , g \circ S)
\end{align*} 

Array satisfies the \alert{universal property} of free monoids!

\end{frame}


\begin{frame}[fragile]{Constructions of free commutative monoids}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \reln
            \\
            (n,f) \reln (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f \id g \comp \phi}
        \end{align*}
    \end{dblock}
    \begin{dblock}[Swapped Cons lists]
        \begin{code}
data SList (A : UU) : UU where
  nil : List A
  _cons_ : A -> List A -> List A
  swap : forall x y xs -> x cons y cons xs == y cons x cons xs 
        \end{code}
    \end{dblock}
    \begin{dblock}[Cons lists quotiented by permutations]
        $\type{PList}(A) = \type{List}(A) / \type{Perm}_{\reln}$
    \end{dblock}
    What is a correct permutation relation? The quotient must satisfy the universal property of free commutative monoids!  
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \reln
            \\
            (n,f) \reln (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f \id g \comp \phi}
        \end{align*}
    \end{dblock}
    \begin{dblock}[Cons lists quotiented by permutations]
        $\type{PList}(A) = \type{List}(A) / \type{Perm}_{\reln}$
    \end{dblock}

    A free monoid quotiented by a \alert{permutation relation} must be a free commutative monoid. From this, a relation $\reln$ is a correct permutation relation iff it:
    \begin{itemize}
        \item is reflexive, symmetric, transitive
        \item is a congruence wrt $\mmult$: $a \reln b \to c \reln d \to a \mmult c \reln b \mmult d$
        \item is commutative: $a \mmult b \reln b \mmult a$
        \item respects $\ext{(\blank)}$: $\forall f. \, a \reln b \to \ext{f}(a) \id \ext{f}(b)$
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \reln
            \\
            (n,f) \reln (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f = g \comp \phi}
        \end{align*}
    \end{dblock}
    How to show $\reln$ respects \alert{commutativity}: $a + b \reln b + a$?

    Let $a = (n , f)$ and $b = (m , g)$, we need to compute an isomorphism $\phi\colon \Fin[n+m]\xto{\sim}\Fin[m+n]$,
    such that: $(f \oplus g) = (g \oplus f) \circ \phi$.

    Define,\footnote{These are using formal operations in symmetric rig groupoids~\footcite{choudhurySymmetriesReversibleProgramming2022}.}
    \begin{align*}
        \phi := \Fin[n+m] \xto{\sim} \Fin[n] + \Fin[m] \xto{\term{swap}_{+}} \Fin[m] + \Fin[n] \xto{\sim} \Fin[m+n] \\
    \end{align*}

        \vspace{-0.6cm}

  % https://q.uiver.app/#q=WzAsMixbMCwwLCJcXHswLDEsXFxkb3RzLG4tMSwgbixuKzEsXFxkb3RzLG4rbS0xXFx9Il0sWzAsMSwiIFxce24sbisxXFxkb3RzLG4rbS0xLDAsMSxcXGRvdHMsbi0xXFx9Il0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibWFwcyB0byJ9fX1dXQ==
\[\begin{tikzcd}[ampersand replacement=\&,cramped]
	{\{\color{red}0,1,\dots,n-1, \color{blue} n,n+1,\dots,n+m-1 \color{black}\}} \\
	{ \{\color{blue}n,n+1\dots,n+m-1, \color{red}0,1,\dots,n-1 \color{black}\}}
    \arrow["\phi", maps to, from=1-1, to=2-1]
\end{tikzcd}\]
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \reln
            \\
            (n,f) \reln (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f \id g \comp \phi}
        \end{align*}
    \end{dblock}
    How to show $\reln$ respects $\ext{(\blank)}$: $\forall f. \, a \reln b \to \ext{f}(a) \id \ext{f}(b)$?

    We can prove this by showing $\ext{f}$ is \alert{invariant under permutation}: for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]$,
    $\ext{f}(n, i) \id \ext{f}(n, i \circ \phi)$.
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]$ $\ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \vc{Theorem statement or proof?}
    \begin{tblock}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, assuming $\phi(0) = 0$, there is a 
    $\psi\colon \Fin[n]\xto{\sim}\Fin[n]$ such that $\phi \circ S = S \circ \psi$.
   
    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{0, 1, 2, 3, \dots\}} \\
    	{ \{0, x, y, z, \dots\}}
        \arrow["\phi", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]

    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{0, 1, 2, \dots\}} \\
    	{ \{x - 1, y - 1, z - 1, \dots\}}
        \arrow["\psi", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]

    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Assuming $\phi(0) = 0$, $\forall \phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]. \, \ext{f}(S(n), i) = \ext{f}(S(n), i \circ \phi)$.
    \[\begin{array}{rlr}
        & \ext{f}(S(n), i \circ \phi) & \\
        =& f(i(\phi(0))) + \ext{f}(n, i \circ \phi \circ S) & \quad\text{(by definition)} \\
        =& f(i(0)) + \ext{f}(n, i \circ \phi \circ S)       & \quad\text{(by assumption)} \\
        =& f(i(0)) + \ext{f}(n, i \circ S \circ \psi)       & \quad\text{(by previous theorem)} \\
        =& f(i(0)) + \ext{f}(n, i \circ S)                  & \quad\text{(by induction)} \\
        =& \ext{f}(S(n), i)                                 & \quad\text{(by definition)} \\
    \end{array}\]
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, there is a $\tau\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$
    such that $\tau(0) = 0$, and $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$.

    Let $k$ be $\phi^{-1}(0)$:

    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{\color{blue}0, 1, 2, \dots, \color{red}k, k+1, k+2, \dots \color{black}\}} \\
    	{ \{\color{blue}x, y, z, \dots, \color{red}0, u, v, \dots \color{black}\}}
        \arrow["\phi", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]

    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{\color{blue}0, 1, 2, \dots, \color{red}k, k+1, k+2, \dots \color{black}\}} \\
    	{ \{\color{red}0, u, v, \dots, \color{blue}x, y, z, \dots \color{black}\}}
        \arrow["\tau", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]
    
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, there is a $\tau\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$
    such that $\tau(0) = 0$, and $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$.

    Let $k$ be $\phi^{-1}(0)$, $k + j = S(n)$:
    
    \begin{align*}
        & \ext{f}(S(n), i \circ \phi) \\
        & = \ext{f}(k + j, g \oplus h) \\
        & = \ext{f}(k, g) + \ext{f}(j, h) & \quad \text{(by homomorphism)} \\
        & = \ext{f}(j, h) + \ext{f}(k, g) & \quad \text{(by commutativity in codomain of $\ext{f}$)}\\
        & = \ext{f}(j + k, h \oplus g)    & \quad \text{(by homomorphism)} \\
        & = \ext{f}(S(n), i \circ \tau)
    \end{align*}
    
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    For all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.
    
    \begin{align*}
        & \ext{f}(S(n), i \circ \phi) \\
        & = \ext{f}(S(n), i \circ \tau) \\
        & = \ext{f}(S(n), i)
    \end{align*}
    
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{\inline{List}s vs \inline{SList}s}
    \inline{Length}

    By the \alert{universal property}: $f : A \to \mathbb{N} := f(x) = 1$,
    $\ext{f} : (S)List(A) \to \mathbb{N}$ gives us the length function!

    
\vspace{1cm}
\adjustbox{scale=1.3,center}{%
% https://q.uiver.app/#q=WzAsMyxbMCwwLCIoUylMaXN0KEEpIl0sWzIsMCwiXFxtYXRoYmJ7Tn0iXSxbMCwyLCJBIl0sWzIsMCwiXFxldGEiXSxbMCwxLCJcXGV4dHtcXGxhbWJkYSB4LiBcXCwgMX0iXSxbMiwxLCJcXGxhbWJkYSB4LiBcXCwgMSIsMl1d
\begin{tikzcd}[ampersand replacement=\&,cramped]
	{(S)List(A)} \&\& {(\mathbb{N}, +)} \\
	\\
	A
	\arrow["\eta", from=3-1, to=1-1]
	\arrow["{\ext{(\lambda x. \, 1)}}", from=1-1, to=1-3]
	\arrow["{\lambda x. \, 1}"', from=3-1, to=1-3]
\end{tikzcd}
}
\end{frame}

\begin{frame}[fragile]{\inline{List}s vs \inline{SList}s}
    \inline{Membership}

    Assuming $A$ is a set, to define membership proof for $x$: $f : A \to \text{hProp} := f(y) = x \equiv y$.

    hProp forms a \alert{commutative monoid} under $\vee$, $\ext{f} : (S)List(A) \to \text{hProp}$ gives us
    the type for membership proof for $x$!

    
\vspace{1cm}
\adjustbox{scale=1.3,center}{%
% https://q.uiver.app/#q=WzAsMyxbMCwwLCIoUylMaXN0KEEpIl0sWzIsMCwiXFxtYXRoYmJ7Tn0iXSxbMCwyLCJBIl0sWzIsMCwiXFxldGEiXSxbMCwxLCJcXGV4dHtcXGxhbWJkYSB4LiBcXCwgMX0iXSxbMiwxLCJcXGxhbWJkYSB4LiBcXCwgMSIsMl1d
\begin{tikzcd}[ampersand replacement=\&,cramped]
	{(S)List(A)} \&\& {(\text{hProp}, \vee)} \\
	\\
	A
	\arrow["\eta", from=3-1, to=1-1]
	\arrow["{\ext{(\lambda y. \, x = y)}}", from=1-1, to=1-3]
	\arrow["{\lambda y. \, x = y}"', from=3-1, to=1-3]
\end{tikzcd}
}
\end{frame}

\begin{frame}{\inline{List}s vs \inline{SList}s}
    \inline{Any} and \inline{All}

    Given a \alert{proposition} on $A$, $f : A \to hProp$,
    $\ext{f} : (S)List(A) \to (hProp, \vee)$ gives us Any and 
    $\ext{f} : (S)List(A) \to (hProp, \wedge)$ gives us All!
   
\vspace{1cm}

\[
\begin{tikzcd}[ampersand replacement=\&,cramped]
	{(S)List(A)} \&\& {(\text{hProp}, \vee)} \\
	\\
	A
	\arrow["\eta", from=3-1, to=1-1]
	\arrow["{\ext{f}}", from=1-1, to=1-3]
	\arrow["{f}"', from=3-1, to=1-3]
\end{tikzcd}
\hspace{1cm}
\begin{tikzcd}[ampersand replacement=\&,cramped]
	{(S)List(A)} \&\& {(\text{hProp}, \wedge)} \\
	\\
	A
	\arrow["\eta", from=3-1, to=1-1]
	\arrow["{\ext{f}}", from=1-1, to=1-3]
	\arrow["{f}"', from=3-1, to=1-3]
\end{tikzcd}
\]


\end{frame}


\begin{frame}[fragile]{\inline{List}s vs \inline{SList}s}
How do we define \inline{head} for List and SList?

The type is \inline{head : List A -> A}.

We consider by cases on the length of the List/SList.

For \alert{empty} List and SList, \inline{head} cannot be defined.

For \alert{singleton} List and SList, \inline{head} is a equivalence.

For List with \alert{of length \geq 2}, we can just take the first element.

For SList with \alert{of length \geq 2}, \inline{head} can only be defined iff there is a \alert{total order}!

By swap, \inline{\{x,y\} = \{y,x\}}, so \inline{head(\{x,y\}) = head(\{y,x\})}.    
\end{frame}

\begin{frame}{\inline{List}s vs \inline{SList}s}
Let $\LL(A)$ be the \alert{free monoid} on $A$ and $\MM(A)$ be the \alert{free commutative monoid} on $A$.

\adjustbox{scale=1.5,center}{%
% https://q.uiver.app/#q=WzAsMixbMCwwLCJcXExMKEEpIl0sWzMsMCwiXFxNTShBKSJdLFsxLDAsInMiLDAseyJjdXJ2ZSI6LTF9XSxbMCwxLCJxIiwwLHsiY3VydmUiOi0xfV1d
\begin{tikzcd}[ampersand replacement=\&,cramped]
	{\LL(A)} \&\&\& {\MM(A)}
	\arrow["s", curve={height=-6pt}, from=1-4, to=1-1]
	\arrow["q", curve={height=-6pt}, from=1-1, to=1-4]
\end{tikzcd}
}


$q$ is the \alert{canonical map} from $\LL(A)$ to $\MM(A)$, given by $\ext{\eta}$.

$s$ is the \alert{section} to $q$, so for all $x$, $q(s(x)) = x$.

$s$ picks a canonical representation out of the equivalence classes generated by commutativity,
is it doing sorting?
    
\end{frame}

\begin{frame}{Sorting}

\begin{qblock}
Total order implies a sorting function, does a sorting function imply total order?
\end{qblock}

Axioms of \alert{total order}:
\begin{itemize}
    \item reflexivity: $x \leq x$
    \item transitivity: if $x \leq y$ and $y \leq z$, then $x \leq z$
    \item antisymmetry: if $x \leq y$ and $y \leq x$, then $x = y$
    \item totality: forall $x$ and $y$, either $x \leq y$ or $y \leq x$ 
\end{itemize}

Given a section $s$, we can construct a relation that satisfies \alert{reflexivity}, \alert{antisymmetry}, and \alert{totality}!

\end{frame}

\begin{frame}{Sorting}

Given a section $s$, let $\text{least}(xs) = \text{head}(s(xs))$. We say $x \, R \, y$ iff $\text{least}(\{x, y\}) = x$

\begin{tblock}
    $\text{least}(s(\{x, y\}))$ must either be $x$ or $y$.
\end{tblock}

\begin{itemize}
    \item \alert{reflexivity}: $x \, R \, x$
    
    $\text{least}(\{x, x\}))$ must be x.
    
    \item \alert{antisymmetry}: if $x \, R \, y$ and $y \, R \, x$, then $x = y$
    
    $x = \text{least}(\{x, y\}) = \text{least}(\{y, x\}) = y$
    
    \item \alert{totality}: forall $x$ and $y$, either $x \, R \, y$ or $y \, R \, x$ 
    
    $\text{least}(\{x, y\})$ must either be $x$ or $y$.
    
\end{itemize}

But what about \alert{transitivity}?

\end{frame}

\begin{frame}{Sorting}

But what about \alert{transitivity}?

Consider a section like $s : SList(\Nat) \to List(\Nat)$:

\begin{align*}
    s(xs) & = \begin{cases}
        \text{sort}(xs)                  & \text{if length($xs$) is odd}   \\
        \text{reverse}(\text{sort}(xs))  & \text{otherwise}
    \end{cases} \\
    s(\{2,3,1,4\}) & = [4,3,2,1] \\
    s(\{2,3,1\}) & = [1, 2, 3]
\end{align*}

$s$ doesn't sort and violate \alert{transitivity}!

More constraint is needed...
    
\end{frame}

\begin{frame}{Sorting}

But what about \alert{transitivity}?
More constraint is needed...

\begin{dblock}
    A list $xs$ is sorted if $\exists ys. \, s(ys) = xs$.
\end{dblock}

\begin{dblock}
    A section $s$ satisfies \textit{is-head-least} if \\
    $\forall x \, xs. \, \text{is-sorted}(x :: xs) \to y \in (x :: xs) \to \text{is-sorted}([x, y])$.
\end{dblock}

With \alert{\textit{is-head-least}}, we can prove $R$ is \alert{transitive}.
   
\end{frame}

\begin{frame}{Sorting}

Given a \alert{decidable total order} $R$, we can use it to construct a sort function (e.g. insertion sort).

Insertion sort satisfies \textit{is-head-least}, we can use it to construct a total order $R'$.

\begin{tblock}
    R' = R
\end{tblock}

Does this mean \textit{is-head-least} is enough to axiomtize sorting functions?

If we use $s$ to construct $R'$, can we reconstruct $s$ from $R'$? 
    
\end{frame}

\begin{frame}{Sorting}

If we use $s$ to construct $R'$, can we reconstruct $s$ from $R'$? 

Consider a section like $s : SList(\Nat) \to List(\Nat)$:

\begin{align*}
    s(xs) & = \text{least}(xs) :: \text{reverse(sort($xs \setminus x$))} \\
    s(\{2,3,1,4\}) & = [1,4,3,2] \\
    s(\{2,3,1\}) & = [1, 3, 2]
\end{align*}

Both $s$ and insertion sort would give us the same $R$!

We need another constraint to get a \alert{full equivalence}:

\begin{dblock}
    A section $s$ satisfies \textit{is-tail-sort} if \\
    $\forall x \, xs. \, \text{is-sorted}(x :: xs) \to \text{is-sorted}(xs)$.
\end{dblock}
    
\end{frame}


\begin{frame}{Main Result}

\begin{dblock}
    $\type{DecTotOrd}(A)$ = type of decidable total orders on $A$

    $\type{Sort}(A)$ = type of sections $s\colon \MM(A) \to \LL(A)$ to $q$
    satisfying $\term{is-head-least}$ and $\term{is-tail-sort}$
    where $A$ has decidable equality
\end{dblock}

\begin{tblock}
    $\term{o2s}\colon \type{DecTotOrd}(A) \to \type{Sort}(A)$ is an equivalence.
\end{tblock}

\end{frame}

\begin{frame}{Main Result}

  \begin{qblock}
    What is a correct sorting algorithm?
  \end{qblock}

  A sort function is a section $s\colon \MM(A) \to \LL(A)$ to the canonical map $\LL(A) \to \MM(A)$,
  satisfying:

\begin{dblock}
    A section $s$ satisfies \textit{is-head-least} if \\
    $\forall x \, xs. \, \text{is-sorted}(x :: xs) \to y \in (x :: xs) \to \text{is-sorted}([x, y])$.
\end{dblock}

\begin{dblock}
    A section $s$ satisfies \textit{is-tail-sort} if \\
    $\forall x \, xs. \, \text{is-sorted}(x :: xs) \to \text{is-sorted}(xs)$.
\end{dblock}


\end{frame}

\begin{frame}{Future work}

How does sorting relates to \alert{axiom of choice}?

\begin{itemize}
    \item The canonical map $q : \LL(A) \to \MM(A)$ is a surjection
    \item AC says every surjection has a section \\
    i.e. we can always choose a canonical representative for each equivalence class
    \item A sorting algorithm produces this representative
\end{itemize}

\end{frame}

\begin{frame}[standout]
    Thank you!
\end{frame}

% \nocite{*}

\begin{frame}[allowframebreaks]
    \frametitle{References}
    \printbibliography[heading=none]
\end{frame}

\end{document}
