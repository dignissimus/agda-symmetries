% !TEX program = lualatex 

\documentclass[9pt]{beamer}

\usetheme{metropolis}
\usepackage{bookmark}
\usepackage{xcolor-solarized}

\setbeamercolor{normal text}{%
  fg=solarized-base02,
  bg=solarized-base3!20!white
}
\setbeamercolor{alerted text}{%
  fg=solarized-red
}
\setbeamercolor{example text}{%
  fg=solarized-green
}
\setbeamercolor{frametitle}{%
    fg=solarized-blue!70!black,
    bg=solarized-base2
}

\setbeamerfont{title}{series=\bfseries,parent=structure}
\setbeamerfont{frametitle}{series=\bfseries,parent=structure}

\usecolortheme{orchid}

\usepackage{hott}
\usepackage{mathtools}
\usepackage{macros}
\usepackage[final]{microtype}

\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{braket}
\usepackage{quiver}
\usepackage{mathtools}
\usepackage{commath}
\usepackage{xparse}
\usepackage{array}
\usepackage{subcaption} %side by side diagrams
\usepackage{caption} %customises captions
\usepackage{floatrow}
\usepackage{tikz} 
\usepackage{tikz-cd}
\usetikzlibrary{babel}% added

% fancy boxes
\usepackage[most]{tcolorbox}

\newtcolorbox{qblock}[1][Question]{
  colback=white,
  colframe=solarized-orange,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}
\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\newtcolorbox{pblock}[1][Proposition]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\newtcolorbox{tblock}[1][Theorem]{
  colback=white,
  colframe=solarized-green,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\usepackage{tikz}
\usetikzlibrary{cd}
\usetikzlibrary{fit}

\usepackage{fontspec}
\setmonofont{Iosevka}[
    Path=./Iosevka/,
    Extension = .ttf,
    UprightFont=*-Regular,
    BoldFont=*-Bold,
    ItalicFont=*-Italic,
    BoldItalicFont=*-BoldItalic
]

%Information to be included in the title page:
\title{On commutativity, total orders, and sorting}
\author[shortname]{
  Wind Wong \inst{1}
  \and Vikraman Choudhury \inst{2}
  \and Simon J. Gay \inst{1}
}
\institute[shortinst]{\inst{1} University of Glasgow \and %
                      \inst{2} Universit\`{a} di Bologna and OLAS Team, INRIA}
\date{February 14, 2024}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Motivation}

  \begin{qblock}
    What is a correct sorting algorithm?
  \end{qblock}

  \begin{itemize}
    \item We learn sorting algorithms in undergraduate ordinateur science.

    \item A sorting algorithm is a \inline{sort : List Nat -> List Nat} function.

    \item For example, \inline{sort([3,1,6,5])} produces \inline{[1,3,5,6]}.

    \item Why is it correct?

          \begin{itemize}
            \item In ordered lists, elements are accessed in order by their indices.

            \item The in-order access matches the ordering on numbers:
                  \[
                  l(0) \leq l(1) \leq l_{3}(2) \leq l_{4}
                  \]

            \item Or, any two consecutive pairs of elements are ordered:
                  \[
                  l(0) \leq l(1), l(1) \leq l(3), l(0) \leq l(2) \ldots
                  \]
            \item What determines correctness of sorting? We need to study them abstractly!
          \end{itemize}
    \item The type \inline{sort : List Nat -> List Nat} is very imprecise, can we give it a more precise type?
  \end{itemize}
\end{frame}

\begin{frame}{Motivation}

  We will need some background, and use some technology:

\begin{itemize}

  \item We will study algebraic structures, using a framework for \alert{universal algebra}, that we have developed in type theory. Using this framework, we define free algebras and their universal properties.

  \item We study two specific algebraic structures: \alert{monoids} and \alert{commutative monoids}, which are crucial to sorting, and the corresponding constructions of \alert{free monoids} and \alert{free commutative monoids}.

  \item Using this framework, we will formally define:
    \begin{itemize}
        \item What is a sorting algorithm?
        \item When is a sorting algorithm correct?
    \end{itemize}

  \item We will show that these correctness criteria are complete, by connecting them to the theory of \alert{total orders}. This gives us an \alert{axiomatics of sorting}.

  \item These ideas come from category theory and universal properties. We work in univalent type theory (in particular, \alert{Cubical Agda}), which gives us powerful tools to implement these ideas correctly, and compute with them.
  
  %% gives us higher inductive types, which allows us to reason with
  %% commutativity and equations of algebras. (No setoid hell!)

\end{itemize}

\end{frame}

\begin{frame}{Homotopy Type Theory}
\frametitle{Homotopy Type Theory}

Homotopy Type Theory (HoTT) is an extension of intensional MLTT.
%% and allows us to reason with equivalences more powerfully.

\begin{itemize}

  \item Function extensionality: $\forall x. \, f(x) = g(x) \rightarrow f = g$)

  \item Quotient types: $Q = A / R$ (via higher inductive types)

  \item Homotopy types: contractible types, propositions, sets, groupoids, 2-groupoids, \ldots

  \item Richer notion of equality types (or identity types or Path types)

  \item and many more \ldots

\end{itemize}

\end{frame}

\begin{frame}{Function Extensionality}
\frametitle{Homotopy Type Theory}

Function extensionality: $\forall x. \, f(x) = g(x) \rightarrow f = g$

\begin{itemize}

  \item MLTT by itself does not have function extensionality

  \item It has to be added as an axiom (we lose \alert{canonicity}!)

  \item<2-> funExt can be derived as a theorem in HoTT

\end{itemize}

\end{frame}

\begin{frame}{Quotient Types}
\frametitle{Homotopy Type Theory}

Quotient Types:

\begin{itemize}

  \item In MLTT we can only emulate quotient types with setoids
  \item We need to prove functions are setoid homomorphisms when defining a function
  \item A lot of proof obligation (\alert{setoid hell}!)
  \item<2-> HoTT lets us define quotient types directly with HITs

\end{itemize}

\end{frame}

\begin{frame}{Mere Proposition}
\frametitle{Homotopy Type Theory}

Mere Proposition:

\begin{itemize}

  \item In MLTT we don't have a distinction between sets and propositions (both are types)
  \item We might end up needing a \alert{stronger theorem} to prove a proposition
  \item E.g. existential proofs are done with $\Sigma$-types, requiring us to \alert{construct} the element
  \item<2-> HoTT allows us to have types that are "\alert{mere propositions}"
  \item<2-> E.g. existential proofs can be done with propositionally truncated $\Sigma$-types (mere existence)
  \item<2-> We can use mere existential proofs to prove other propositions even \alert{without} having the specific element

\end{itemize}

\end{frame}

\begin{frame}{Equalities between Types}
\frametitle{Homotopy Type Theory}
Equalities between types:

\begin{itemize}

  \item In MLTT we don't have equalities between types
  \item HoTT gives us equalities between types by the \alert{univalence axiom}
  \item E.g. given $A, B : \mathcal{U}, P : \mathcal{U} \rightarrow \mathcal{U}, A = B$,
        we can get $P(B)$ from $P(A)$ by transport (substitution)

\end{itemize}

\uncover<2->{
\begin{dblock}
  Given types $A$ and $B$, $A$ is equivalent to $B$ ($A \simeq B$) if there exists an
  equivalence $A \rightarrow B$.
  A function $f$ is said to be an equivalence if
  $\left( \sum_{g :B \rightarrow A} (f \circ g \sim \mathrm{id}_B) \right) \times \left( \sum_{g:B \rightarrow A} (g \circ f \sim \mathrm{id}_A) \right)$.
\end{dblock}

\begin{tblock}[Univalence axiom]
  $(A = B) \simeq (A \simeq B)$
\end{tblock}
}

\end{frame}

\begin{frame}{Homotopy Levels}
\frametitle{Homotopy Levels}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  \\
  % & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}

\begin{frame}{Contractible Types}
\frametitle{Homotopy Levels}

H-Level 0: Contractible types

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
\end{align*}

There exists a \alert{center of contraction} such that all elements of $A$ are equal to
the center of contraction.

Examples:
\begin{itemize}
  \item $\mathbf{1}$ (Unit type)
\end{itemize}

All contractible types are equivalent to $\mathbf{1}$!

\end{frame}

\begin{frame}{Propositional Types}
\frametitle{Homotopy Levels}

H-Level 1: Mere propositions

\begin{align*}
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
\end{align*}

All elements of $A$ are equal to each other.

Examples:
\begin{itemize}
  \item $\mathbf{1}$ (Unit type)
  \item $\mathbf{0}$ (Void type)
\end{itemize}

All h-propositions are equivalent to either $\mathbf{1}$ or $\mathbf{0}$.

A type that represents a proposition should be an $\mathsf{hProp}$.

E.g. mere existential proofs can be done with a truncated $\Sigma$-type.
($\Sigma$-type wrapped in a HIT that makes all its elements equal.)

\end{frame}

\begin{frame}{Sets}
\frametitle{Homotopy Levels}

H-Level 2: Sets

\begin{align*}
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
\end{align*}

The identity type of $A$ is a proposition.
All elements of $x = x$ are equal.

Examples:
\begin{itemize}
  \item $\mathbf{1}$, $\mathbf{0}$
  \item $\mathbb{N}$
  \item $\mathsf{hProp}$ ($\sum_{A : \mathcal{U}} \text{isProp}(A)$)
\end{itemize}

For the scope of the project, this is primarily what we are working with!

\end{frame}

\begin{frame}[fragile]
\frametitle{Homotopy Levels}

H-Level 2: Sets

\begin{align*}
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
\end{align*}

In a type theory with \alert{K-axiom} / \alert{uniqueness of identity proof} (UIP), all types
are h-sets.

E.g. Idris2 lets us prove UIP by pattern matching:

    \begin{dblock}[UIP]
        \begin{code}
uip : (A : Type) -> (x, y : A) -> (p, q : x = y) -> p = q
uip A x x Refl Refl = Refl
        \end{code}
    \end{dblock}

We can embed extensional type theory into HoTT with h-sets.

\end{frame}


\begin{frame}{Groupoids}
\frametitle{Homotopy Levels}

H-Level 3: Groupoids

\begin{align*}
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
\end{align*}

The identity type of $A$ is a set.

Examples:
\begin{itemize}
  \item Any type that satisfies $\text{isSet}$...
  \item $\mathsf{hSet}$ ($\sum_{A : \mathcal{U}} \text{isSet}(A)$)
\end{itemize}

Consider $\mathbb{B} : \mathsf{hSet}$, univalence gives us two $\mathbb{B} = \mathbb{B}$
generated by \alert{id} and \alert{not}.

These two equalities are not equal!

\end{frame}

\begin{frame}{Homotopy Levels}
\frametitle{Homotopy Levels}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  \\
  % & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}


\begin{frame}[fragile]{Higher Inductive Types}
\frametitle{Higher Inductive Types}

\begin{code}
-- ordered lists
data List (A : Type) : Type where
  nil : List A
  _::_ : A -> List A -> List A

-- swap lists or unordered lists or finite multisets
data SList (A : Type) : Type where
  []    : SList A
  _::_  : (x : A) -> (xs : SList A) -> SList A
  swap  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (SList A)
  -- alternatively
  -- trunc : (x y : SList A) -> (p q : x == y) -> p == q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
data FMSet (A : Type) : Type where
  []    : FMSet A
  _::_  : (x : A) -> (xs : FMSet A) -> FMSet A
  swap  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (FMSet A)

_++_ : ∀ (xs ys : FMSet A) → FMSet A
[] ++ ys = ys
(x :: xs) ++ ys = x :: xs ++ ys
swap x y xs i ++ ys =
  -- proof x :: y :: (xs ++ ys) ≡ y :: x :: (xs ++ ys)
trunc xs zs p q i j ++ ys =
  -- proof cong (_++ ys) p ≡ cong (_++ ys) q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
-- Set quotient
data _/_ (A : Type) (R : A → A → Type) : Type where
  [_] : (a : A) → A / R
  eq/ : (a b : A) → (r : R a b) → [ a ] ≡ [ b ]
  squash/ : (x y : A / R) → (p q : x ≡ y) → p ≡ q

data Perm {A : Type} : List A -> List A -> Type where
  perm-refl : ∀ {xs} -> Perm xs xs
  perm-swap : ∀ {x y xs ys zs}
    -> Perm (xs ++ x ∷ y ∷ ys) zs
    -> Perm (xs ++ y ∷ x ∷ ys) zs

-- Swap list as quotient
PList : Type -> Type
PList A = List A / Perm
\end{code}

\end{frame}

\begin{frame}
\frametitle{Cubical Type Theory}

\begin{itemize}

  \item The project is formalized in \alert{Cubical Agda}, an implementation of Cubical Type Theory
  \item Cubical Type Theory is a variant of HoTT that doesn't lose \alert{computational properties} of type theory
        (no axioms, has \alert{canonicity})
  \item Univalence is not postulated and can be computationally derived
  \item Designed to preserve \alert{canonicity}, using univalence won't destroy computational content of a proof

\end{itemize}


\end{frame}

\begin{frame}{Universal Algebra}
\frametitle{Universal Algebra}
A \alert{signature} $\sigma$ =
\begin{itemize}
    \item a set of \alert{operation symbols} $op : \mathsf{Set}$
    \item an \alert{arity function} $ar : \sigma \rightarrow \mathsf{Set}$
\end{itemize}

This gives a signature endofunctor $F_{\sigma}(X) := \sum_{f : op} X^{ar(f)}$

A $F_{\sigma}$-algebra is:
\begin{itemize}
    \item a \alert{carrier set} $X : Set$
    \item an \alert{evaluation function}: $\alpha_X\colon\Sig(X) \to X$
\end{itemize}

A $\sigma$-algebra homomorphism $h: A \rightarrow B$ is a function such that \\
for all $(\sigma, a_1, \dots, a_n) : F_{\sigma}(X)$:
\begin{align*}
    h(\alpha_A(\sigma, a_1, \dots, a_n)) = \alpha_B(\sigma, h(a_1), \dots, h(a_n))
\end{align*}

$F_{\sigma}$-algebras and their morphisms form a category $\sigma$-Alg.

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}
Example: $\mathbb{N}$ as a monoid

The signature $\sigma$ =
\begin{itemize}
    \item the set of operation symbols $op : \mathsf{Set} = \{e, +\}$
    \item the arity function $ar : \sigma \rightarrow \mathsf{Set} = \{e \mapsto \mathbf{0}, + \mapsto \mathbb{B}\}$
\end{itemize}

The algebra has the carrier set $\mathbb{N}$ and the evaluation function:

\begin{align*}
\alpha(e) & = 0 \\
\alpha(+, a, b) & = a + b 
\end{align*} 


\end{frame}


\begin{frame}{Free Object}
\frametitle{Free Objects}

The forgetful functor $\sigma$-Alg to $Set$ admits a left adjoint

This gives us a free $\sigma$-algebra construction on a carrier set

\begin{dblock}[The universal property of a free object]
For any object \( \mathfrak{Y} \) in $\sigma$-Alg and any map between sets \( g : X \to U(\mathfrak{Y}) \),
there exists a unique morphism \( f : F(X) \to \mathfrak{Y} \) in $\sigma$-Alg such that \( g = U(f) \circ \eta \):

% https://q.uiver.app/#q=WzAsMyxbMCwwLCJYIl0sWzIsMCwiVShBKSJdLFsyLDIsIlUoQikiXSxbMCwxLCJpIiwwLHsiY29sb3VyIjpbMSwxMDAsNjBdfSxbMSwxMDAsNjAsMV1dLFswLDIsImciLDJdLFsxLDIsIlUoZikiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XV0=
\[
\begin{tikzcd}[ampersand replacement=\&]
	F(X) \\
	\\
	\mathfrak{Y}
	\arrow["f", dotted, from=1-1, to=3-1]
\end{tikzcd}
\hspace{1cm}
\begin{tikzcd}[ampersand replacement=\&]
	X \&\& {U(F(X))} \\
	\\
	\&\& {U(\mathfrak{Y})}
	\arrow["\eta", color={rgb,255:red,255;green,54;blue,51}, from=1-1, to=1-3]
	\arrow["g"', from=1-1, to=3-3]
	\arrow["{U(f)}", dotted, from=1-3, to=3-3]
\end{tikzcd}\]

where $U$ is the forgetful functor and $\eta : X \rightarrow F(X)$ is the canonical injection.
\end{dblock}

\end{frame}

\begin{frame}
\frametitle{Free Objects}

We can construct a a free $\sigma$-algebra on $V$ as an inductive type $Tr_\sigma(V)$:
\begin{itemize}
    \item $\text{leaf} : V \rightarrow Tr_\sigma(V)$
    \item $\text{node} : \sum_f(Tr_\sigma(V)^{ar(f)}) \rightarrow Tr_\sigma(V)$
\end{itemize}

node is our \alert{evaluation function} $\alpha : F_\sigma(Tr_\sigma(V)) \rightarrow Tr_\sigma(V)$

leaf is our \alert{canonical injection} $\eta : V \rightarrow Tr_\sigma(V)$

This forms a $\sigma$-algebra $\str{T}(V) = (\tree{V}, \term{node})$

By the \alert{universal property}: $(\blank) \comp \eta \colon \sigAlg(\str{T}(V),\str{X}) \xto{\sim} (V \to X)$

The inverse to the equivalence: the \alert{extension operation} $\ext{(\blank)}$,
maps $f\colon V \to X$ to a homomorphism $\ext{f}\colon \str{T}(V) \to \str{X}$

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}

An \alert{equation signature} $\epsilon$ is defined by:
\begin{itemize}
    \item A set of \alert{equation symbols} $eq : Set$
    \item an \alert{arity function} for free variables $fv : eq \to Set$
\end{itemize}

We define a system of equation (or a \alert{theory} $T$) with pairs of trees on the set of free variables:
$l, r : (e : eq) \to Tr_\sigma(fv(e))$

$\mathfrak{X}$ satisfies $T$ ($\mathfrak{X} \entails T$) if for all $e : eq$ and $\rho : fv(e) \to X$,
$\ext{\rho}(l(e)) = \ext{\rho}(r(e))$

Essentially:
\begin{itemize}
    \item $\rho : fv(e) \to X$ maps free variables in equations to elements of $X$
    \item $\ext{\rho} : Tr_\sigma(fv(e)) \to X$ evaluates a tree given some variables
\end{itemize}

Because $\ext{\rho}$ is a \alert{homomorphism}, it must evaluate the tree correctly!

\end{frame}

\begin{frame}[fragile]{Constructions of free monoids}
    \begin{dblock}[Cons Lists]
        \begin{code}
data List (A : UU) : UU where
  nil : List A
  _cons_ : A -> List A -> List A
        \end{code}
    \end{dblock}
    \begin{dblock}[Array]
        $\type{Array}(A) = \dsum{n\colon\Nat}{f : \Fin[n] \to A}$
    \end{dblock}
    Each construction satisfies the universal property of free monoids.
\end{frame}

\begin{frame}[fragile]{Constructions of free monoids}
    \begin{dblock}[Cons Lists]
        \begin{code}
data List (A : UU) : UU where
  nil : List A
  _cons_ : A -> List A -> List A
        \end{code}
    \end{dblock}
We define the $\ext{(\blank)}$ on $f : A \to X$:
\begin{align*}
    \ext{f}([]) & = e \\
    \ext{f}(x :: xs) & =  f(x) + \ext{f}(xs)
\end{align*} 
Then we prove:
\begin{itemize}
    \item $\ext{f}$ is a \alert{homomorphism} $\text{List}(A) \to \mathfrak{X}$
    \item $\ext{(\blank)}$ and $(\blank) \circ [\_]$ are \alert{inverse} of each other.
\end{itemize}

List satisfies the \alert{universal property} of free monoid. Therefore, List is a free monoid!

\end{frame}

\begin{frame}[fragile]{Constructions of free monoids}
    \begin{dblock}[Array]
        $\type{Array}(A) = \dsum{n\colon\Nat}{f : \Fin[n] \to A}$
    \end{dblock}

The monoid operation:
\begin{align*}
    (n , f) + (m , g) & = (n + m , f \oplus g) \\
    (f \oplus g)(o) & = \begin{cases}
      f(o), & \text{if}\ o < n \\
      g(o - n), & \text{otherwise}
    \end{cases}
\end{align*} 

We define the $\ext{(\blank)}$ on $f : A \to X$:
\begin{align*}
    \ext{f}(0 , g) & = e \\
    \ext{f}(S(n) , g) & = f(g(0)) + \ext{f}(n , g \circ S)
\end{align*} 

Array satisfies the \alert{universal property} of free monoid!

\end{frame}


\begin{frame}[fragile]{Constructions of free commutative monoids}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \sim          
            \\
            (n,f) \sim (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f = g \comp \phi}
        \end{align*}
    \end{dblock}
    \begin{dblock}[Swapped Cons lists]
        \begin{code}
data SList (A : UU) : UU where
  nil : List A
  _cons_ : A -> List A -> List A
  swap : forall x y xs -> x cons y cons xs == y cons x cons xs 
        \end{code}
    \end{dblock}
    \begin{dblock}[Cons lists quotiented by permutations]
        $\type{PList}(A) = \type{List}(A) / \type{Perm}$
    \end{dblock}
    Each construction satisfies the universal proeprty of free commutative monoids.    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \sim          
            \\
            (n,f) \sim (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f = g \comp \phi}
        \end{align*}
    \end{dblock}
    \begin{dblock}[Cons lists quotiented by permutations]
        $\type{PList}(A) = \type{List}(A) / \type{Perm}$
    \end{dblock}

    A free monoid quotiented by a \alert{permutation relation} is a free commutative monoid:
    \begin{itemize}
        \item reflexivity, symmetry, transitivity: equality relation
        \item congruence: $a \simeq b \to c \simeq d \to a + c \simeq b + d$
        \item commutativity: $a + b \simeq b + a$
        \item respect $\ext{(\blank)}$: $\forall f. \, a \simeq b \to \ext{f}(a) = \ext{f}(b)$
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \sim          
            \\
            (n,f) \sim (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f = g \comp \phi}
        \end{align*}
    \end{dblock}
    How to show $\simeq$ respects \alert{commutativity}: $a + b \simeq b + a$?

    Let $a = (n , f)$ and $b = (m , g)$, w.t.s. there exists an isomorphism $\phi\colon \Fin[n+m]\xto{\sim}\Fin[m+n]$
    such that: $(f \oplus g) = (g \oplus f) \circ \phi$

    \begin{align*}
        \phi := \Fin[n+m] \xto{\sim} \Fin[n] + \Fin[m] \xto{inl,inr \xto{\sim} inr,inl} \Fin[m] + \Fin[n] \xto{\sim} \Fin[m+n] \\
    \end{align*}

        \vspace{-0.6cm}

  % https://q.uiver.app/#q=WzAsMixbMCwwLCJcXHswLDEsXFxkb3RzLG4tMSwgbixuKzEsXFxkb3RzLG4rbS0xXFx9Il0sWzAsMSwiIFxce24sbisxXFxkb3RzLG4rbS0xLDAsMSxcXGRvdHMsbi0xXFx9Il0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibWFwcyB0byJ9fX1dXQ==
\[\begin{tikzcd}[ampersand replacement=\&,cramped]
	{\{\color{red}0,1,\dots,n-1, \color{blue} n,n+1,\dots,n+m-1 \color{black}\}} \\
	{ \{\color{blue}n,n+1\dots,n+m-1, \color{red}0,1,\dots,n-1 \color{black}\}}
    \arrow["\phi", maps to, from=1-1, to=2-1]
\end{tikzcd}\]
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    \begin{dblock}[Arrays quotiented by symmetries]
        \vspace{-0.4cm}
        \begin{align*}
            \type{Bag}(A) &= Array(A) / \sim          
            \\
            (n,f) \sim (m,g) &= 
                \exis{\phi\colon \Fin[n]\xto{\sim}\Fin[m]}{f = g \comp \phi}
        \end{align*}
    \end{dblock}
    How to show $\simeq$ respects $\ext{(\blank)}$: $\forall f. \, a \simeq b \to \ext{f}(a) = \ext{f}(b)$?

    We can prove this by showing $\ext{f}$ is \alert{invariant to permutation}: for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]$,
    $\ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]$ $\ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, assuming $\phi(0) = 0$, there is a 
    $\psi\colon \Fin[n]\xto{\sim}\Fin[n]$ such that $\phi \circ S = S \circ \psi$.
   
    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{0, 1, 2, 3, \dots\}} \\
    	{ \{0, x, y, z, \dots\}}
        \arrow["\phi", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]

    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{0, 1, 2, \dots\}} \\
    	{ \{x - 1, y - 1, z - 1, \dots\}}
        \arrow["\psi", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]

    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Assuming $\phi(0) = 0$, $\forall \phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]. \, \ext{f}(S(n), i) = \ext{f}(S(n), i \circ \phi)$.
    \begin{align*}
        & \ext{f}(S(n), i \circ \phi) \\
        & = f(i(\phi(0))) + \ext{f}(n, i \circ \phi \circ S) & \quad\text{(by definition)} \\
        & = f(i(0)) + \ext{f}(n, i \circ \phi \circ S)       & \quad\text{(by assumption)} \\
        & = f(i(0)) + \ext{f}(n, i \circ S \circ \psi)       & \quad\text{(by previous theorem)} \\
        & = f(i(0)) + \ext{f}(n, i \circ S)                  & \quad\text{(by induction)} \\
        & = \ext{f}(S(n), i)                                 & \quad\text{(by definition)} \\
    \end{align*}
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, there is a $\tau\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$
    such that $\tau(0) = 0$, and $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$.

    Let $k$ be $\phi^{-1}(0)$:

    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{\color{blue}0, 1, 2, \dots, \color{red}k, k+1, k+2, \dots \color{black}\}} \\
    	{ \{\color{blue}x, y, z, \dots, \color{red}0, u, v, \dots \color{black}\}}
        \arrow["\phi", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]

    \[\begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\{\color{blue}0, 1, 2, \dots, \color{red}k, k+1, k+2, \dots \color{black}\}} \\
    	{ \{\color{red}0, u, v, \dots, \color{blue}x, y, z, \dots \color{black}\}}
        \arrow["\tau", maps to, from=1-1, to=2-1]
    \end{tikzcd}\]
    
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    Given $\phi\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$, there is a $\tau\colon \Fin[S(n)]\xto{\sim}\Fin[S(n)]$
    such that $\tau(0) = 0$, and $\ext{f}(S(n), i \circ \phi) = \ext{f}(S(n), i \circ \tau)$.

    Let $k$ be $\phi^{-1}(0)$, $j + k = S(n)$:
    
    \begin{align*}
        & \ext{f}(S(n), i \circ \phi) \\
        & = \ext{f}(j + k, g \oplus h) \\
        & = \ext{f}(j, g) + \ext{f}(k, h) & \quad \text{(by homomorphism)} \\
        & = \ext{f}(k, h) + \ext{f}(j, g) & \quad \text{(by commutativity in codomain of $\ext{f}$)}\\
        & = \ext{f}(k + j, h \oplus g)    & \quad \text{(by homomorphism)} \\
        & = \ext{f}(S(n), i \circ \tau)
    \end{align*}
    
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{Arrays quotiented by symmetries}
    W.T.S. for all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.

    \begin{tblock}
    For all $\phi\colon \Fin[n]\xto{\sim}\Fin[n]. \, \ext{f}(n, i) = \ext{f}(n, i \circ \phi)$.
    
    \begin{align*}
        & \ext{f}(S(n), i \circ \phi) \\
        & = \ext{f}(S(n), i \circ \tau) \\
        & = \ext{f}(S(n), i)
    \end{align*}
    
    \end{tblock}
    
\end{frame}

\begin{frame}[fragile]{\inline{List}s vs \inline{SList}s}
    \begin{itemize}
        \item length
        \item membership
        \item \inline{Any} and \inline{All}
        \item \inline{head} function
    \end{itemize}
\end{frame}


\begin{frame}{Main Result}

\begin{dblock}
    $\type{DecTotOrd}(A)$ = type of decidable total orders on $A$

    $\type{Sort}(A)$ = type of sections $s\colon \MM(A) \to \LL(A)$ to $q$ satisfying $\term{is-sort}$
\end{dblock}

\begin{tblock}
    $\term{o2s}\colon \type{DecTotOrd}(A) \to \type{Sort}(A)$ is an equivalence.
\end{tblock}

\end{frame}

\begin{frame}[standout]
    Thank you!
\end{frame}

\end{document}
