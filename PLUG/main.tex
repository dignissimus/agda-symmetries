% !TEX program = lualatex 

\documentclass[9pt]{beamer}

\useoutertheme{metropolis}
\useinnertheme{metropolis}
\usecolortheme{metropolis}
\usepackage{xcolor-solarized}

\setbeamercolor{normal text}{%
  fg=solarized-base02,
  bg=solarized-base3!20!white
}
\setbeamercolor{alerted text}{%
  fg=solarized-red
}
\setbeamercolor{example text}{%
  fg=solarized-green
}
\setbeamercolor{frametitle}{%
    fg=solarized-blue!70!black,
    bg=solarized-base2
}

\usecolortheme{orchid}

\usepackage{hott}
\usepackage{mathtools}
\usepackage{macros}
\usepackage[final]{microtype}

\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{braket}
\usepackage{quiver}
\usepackage{mathtools}
\usepackage{commath}
\usepackage{xparse}
\usepackage{array}
\usepackage{subcaption} %side by side diagrams
\usepackage{caption} %customises captions
\usepackage{floatrow}
\usepackage{tikz} 
\usepackage{tikz-cd}
\usetikzlibrary{babel}% added

% fancy boxes
\usepackage[most]{tcolorbox}

\newtcolorbox{qblock}[1][Question]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}
\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\newtcolorbox{tblock}[1][Proposition]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-0.1cm, xshift=0.5em}
}

\usepackage{tikz}
\usetikzlibrary{cd}
\usetikzlibrary{fit}

\usepackage{fontspec}
\setmonofont{Iosevka}[
    Path=./Iosevka/,
    Extension = .ttf,
    UprightFont=*-Regular,
    BoldFont=*-Bold,
    ItalicFont=*-Italic,
    BoldItalicFont=*-BoldItalic
]

%Information to be included in the title page:
\title{On commutativity, total orders, and sorting}
\author[shortname]{
  Wind Wong \inst{1}
  \and Vikraman Choudhury \inst{2}
  \and Simon J. Gay \inst{1}
}
\institute[shortinst]{\inst{1} University of Glasgow \and %
                      \inst{2} Universit\`{a} di Bologna and OLAS Team, INRIA}
\date{February 14, 2024}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Motivation}

  \begin{qblock}
    What is a correct sorting algorithm?
  \end{qblock}

  \begin{itemize}
    \item We learn sorting algorithms in undergraduate ordinateur science.

    \item A sorting algorithm is a \inline{sort : List Nat -> List Nat} function.

    \item For example, \inline{sort([3,1,6,5])} produces \inline{[1,3,5,6]}.

    \item Why is it correct?

          \begin{itemize}
            \item In ordered lists, elements are accessed in order by their indices.

            \item The in-order access matches the ordering on numbers:
                  \[
                  l(0) \leq l(1) \leq l_{3}(2) \leq l_{4}
                  \]

            \item Or, any two consecutive pairs of elements are ordered:
                  \[
                  l(0) \leq l(1), l(1) \leq l(3), l(0) \leq l(2) \ldots
                  \]
            \item What determines correctness of sorting? We need to study them abstractly!
          \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Motivation}

  We will need some background, and use some technology:

\begin{itemize}

  \item We will study algebraic structures, using a framework for \alert{universal algebra}, that we have developed in type theory. Using this framework, we define free algebras and their universal properties.

  \item We study two specific algebraic structures: \alert{monoids} and \alert{commutative monoids}, which are crucial to sorting, and the corresponding constructions of \alert{free monoids} and \alert{free commutative monoids}.

  \item Using this framework, we will formally define:
    \begin{itemize}
        \item What is a sorting algorithm?
        \item When is a sorting algorithm correct?
    \end{itemize}

  \item We will show that these correctness criteria are complete, by connecting them to the theory of \alert{total orders}. This gives us an \alert{axiomatics of sorting}.

  \item These ideas come from category theory and universal properties. We work in univalent type theory (in particular, \alert{Cubical Agda}), which gives us powerful tools to implement these ideas correctly, and compute with them.
  
  %% gives us higher inductive types, which allows us to reason with
  %% commutativity and equations of algebras. (No setoid hell!)

\end{itemize}
♑
\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Homotopy Type Theory (HoTT) is an extension of intensional MLTT.
%% and allows us to reason with equivalences more powerfully.

\begin{itemize}

  \item Function extensionality: $\forall x. \, f(x) = g(x) \rightarrow f = g$)

  \item Quotient types: $Q = A / R$ (via higher inductive types)

  \item Homotopy types: contractible types, propositions, sets, groupoids, 2-groupoids, \ldots

  \item Richer notion of equality types (or identity types or Path types)

  \item and many more \ldots

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}
♑
Function extensionality: $\forall x. \, f(x) = g(x) \rightarrow f = g$

\begin{itemize}

  \item MLTT by itself does not have function extensionality

  \item It has to be added as an axiom (we lose canonicity!)

  \item<2-> funExt can be derived as a theorem in HoTT

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Quotient Types:

\begin{itemize}

  \item In MLTT we can only emulate quotient types with setoids
  \item We need to prove functions are setoid homomorphisms when defining a function
  \item A lot of proof obligation
  \item<2-> HoTT lets us define quotient types directly with HITs (no more setoid hell!)
♑
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}

Mere Proposition:

\begin{itemize}

  \item In MLTT we don't have a distinction between sets and propositions (both are types)
  \item We might end up needing a stronger theorem to prove a proposition
  \item E.g. existential proofs are done with $\Sigma$-types, requiring us to construct the element
  \item<2-> HoTT allows us to have types that are "mere propositions"
  \item<2-> E.g. existential proofs can be done with propositionally truncated $\Sigma$-types (mere existence)
  \item<2-> We can use mere existential proofs to prove other propositions, even if we don't have the specific element

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Homotopy Type Theory}
Equalities between types:

\begin{itemize}

  \item In MLTT we don't have equalities between types
  \item HoTT gives us equalities between types by the univalence axiom 
  \item E.g. given $A, B : \mathcal{U}, P : \mathcal{U} \rightarrow \mathcal{U}, A = B$,
        we can get $P(B)$ from $P(A)$ by transport (substitution)

\end{itemize}

\uncover<2->{
\begin{block}{Definition}
  Given types $A$ and $B$, $A$ is equivalent to $B$ ($A \simeq B$) if there exists an
  equivalence $A \rightarrow B$.
  A function $f$ is said to be an equivalence if
  $\left( \sum_{g :B \rightarrow A} (f \circ g \sim \mathrm{id}_B) \right) \times \left( \sum_{g:B \rightarrow A} (g \circ f \sim \mathrm{id}_A) \right)$.
\end{block}

\begin{block}{Univalence axiom}
  $(A = B) \simeq (A \simeq B)$
\end{block}
}

\end{frame}

\begin{frame}
\frametitle{Homotopy Levels}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  \\
  % & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}

\begin{frame}
\frametitle{Homotopy Levels}

H-Level 0: Contractible types

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
\end{align*}

There exists a center of contraction such that all elements of $A$ equals to
the center of contraction.

Examples:
\begin{itemize}
  \item $\mathbf{1}$ (Unit type)
\end{itemize}

All contractible types are equivalent to $\mathbf{1}$!

\end{frame}

\begin{frame}
\frametitle{Homotopy Levels}

H-Level 1: Mere propositions

\begin{align*}
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
\end{align*}

All elements of $A$ are equal to each other.

Examples:
\begin{itemize}
  \item $\mathbf{1}$ (Unit type)
  \item $\mathbf{0}$ (Void type)
\end{itemize}

All h-propositions are equivalent to either $\mathbf{1}$ or $\mathbf{0}$.

A type that represents a proposition should be an $\mathsf{hProp}$.

E.g. mere existential proofs can be done with a truncated $\Sigma$-type.
($\Sigma$-type wrapped in a HIT that makes all its elements equal.)

\end{frame}

\begin{frame}
\frametitle{Homotopy Levels}

H-Level 2: Sets

\begin{align*}
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
\end{align*}

The identity type of $A$ is a proposition.
All elements of $x = x$ are equal.

Examples:
\begin{itemize}
  \item $\mathbf{1}$, $\mathbf{0}$
  \item $\mathbb{N}$
  \item $\mathsf{hProp}$ ($\sum_{A : \mathcal{U}} \text{isProp}(A)$)
\end{itemize}

For the scope of the project, this is primarily what we are working with!

\end{frame}

\begin{frame}[fragile]
\frametitle{Homotopy Levels}

H-Level 2: Sets

\begin{align*}
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
\end{align*}

In a type theory with K-axiom / uniqueness of identity proof (UIP), all types
are h-sets.

E.g. Idris2 lets us prove UIP by pattern matching:

\begin{code}
uip : (A : Type) -> (x, y : A) -> (p, q : x = y) -> p = q
uip A x x Refl Refl = Refl
\end{code}

We can embed extensional type theory into HoTT with h-sets.

\end{frame}


\begin{frame}
\frametitle{Homotopy Levels}

H-Level 3: Groupoids

\begin{align*}
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
\end{align*}

The identity type of $A$ is a set.

Examples:
\begin{itemize}
  \item Any type that satisfies $\text{isSet}$...
  \item $\mathsf{hSet}$ ($\sum_{A : \mathcal{U}} \text{isSet}(A)$)
\end{itemize}

Consider $\mathbb{B} : \mathsf{hSet}$, univalence gives us two $\mathbb{B} = \mathbb{B}$
generated by $\text{id}$ and $\text{not}$.

These two equalities are not equal!

\end{frame}

\begin{frame}
\frametitle{Homotopy Levels}

\begin{align*}
  \text{isContr}(A) & \coloneqq \sum_{(a:A)} \prod_{(x:A)} (a = x).
  \\
  % & \text{(e.g. $\mathbf{1}$)} \\
  \text{isProp}(A) & \coloneqq \prod_{(x,y:A)} (x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}$)} \\
  \text{isSet}(A) & \coloneqq \prod_{(x,y:A)} \text{isProp}(x = y).
  \\
  % & \text{(e.g. $\mathbf{1}, \mathbf{0}, \mathbb{N}, \mathsf{hProp}$)} \\
  \text{isGroupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isSet}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hSet}$)} \\
  \text{is2Groupoid}(A) & \coloneqq \prod_{(x,y:A)} \text{isGroupoid}(x = y).
  \\
  % & \text{(e.g. $\mathsf{hGroupoid}$)} \\
  \shortvdotswithin{=}
\end{align*}

\end{frame}


\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
-- ordered lists
data List (A : Type) : Type where
  nil : List A
  _::_ : A -> List A -> List A

-- swap lists or unordered lists or finite multisets
data SList (A : Type) : Type where
  []    : SList A
  _::_  : (x : A) -> (xs : SList A) -> SList A
  swap  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (SList A)
  -- alternatively
  -- trunc : (x y : SList A) -> (p q : x == y) -> p == q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
data FMSet (A : Type) : Type where
  []    : FMSet A
  _::_  : (x : A) -> (xs : FMSet A) -> FMSet A
  swap  : forall x y xs -> x :: y :: xs == y :: x :: xs
  trunc : isSet (FMSet A)

_++_ : ∀ (xs ys : FMSet A) → FMSet A
[] ++ ys = ys
(x :: xs) ++ ys = x :: xs ++ ys
swap x y xs i ++ ys =
  -- proof x :: y :: (xs ++ ys) ≡ y :: x :: (xs ++ ys)
trunc xs zs p q i j ++ ys =
  -- proof cong (_++ ys) p ≡ cong (_++ ys) q
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Higher Inductive Types}

\begin{code}
-- Set quotient
data _/_ (A : Type) (R : A → A → Type) : Type where
  [_] : (a : A) → A / R
  eq/ : (a b : A) → (r : R a b) → [ a ] ≡ [ b ]
  squash/ : (x y : A / R) → (p q : x ≡ y) → p ≡ q

data Perm {A : Type} : List A -> List A -> Type where
  perm-refl : ∀ {xs} -> Perm xs xs
  perm-swap : ∀ {x y xs ys zs}
    -> Perm (xs ++ x ∷ y ∷ ys) zs
    -> Perm (xs ++ y ∷ x ∷ ys) zs

-- Swap list as quotient
PList : Type -> Type
PList A = List A / Perm
\end{code}

\end{frame}

\begin{frame}
\frametitle{Cubical Type Theory}

\begin{itemize}

  \item The project is formalized in Cubical Agda, an implementation of Cubical Type Theory
  \item Cubical Type Theory is a variant of HoTT that doesn't lose computational properties of type theory (no axioms, has canonicity)
  \item Univalence is not postulated and can be computationally derived
  \item Axioms are designed to preserve canonicity, using univalence won't destroy computational content of a proof

\end{itemize}


\end{frame}

\begin{frame}
\frametitle{Universal Algebra}
A signature $\sigma$ =
\begin{itemize}
    \item a set of operation symbols $op : \mathsf{Set}$
    \item an arity function $ar : \sigma \rightarrow \mathsf{Set}$
\end{itemize}

This gives a signature endofunctor $F_{\sigma}(X) := \sum_{f : op} X^{ar(f)}$

A $F_{\sigma}$-algebra is:
\begin{itemize}
    \item a carrier set $X : Set$
    \item an evaluation function: $\alpha_X\colon\Sig(X) \to X$
\end{itemize}

A $\sigma$-algebra homomorphism $h: A \rightarrow B$ is a function such that \\
for all $(\sigma, a_1, \dots, a_n) : F_{\sigma}(X)$:
\begin{align*}
    h(\alpha_A(\sigma, a_1, \dots, a_n)) = \alpha_B(\sigma, h(a_1), \dots, h(a_n))
\end{align*}

$F_{\sigma}$-algebras and their morphisms form a category $\sigma$-Alg.

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}
Example: $\mathbb{N}$ as a monoid

The signature $\sigma$ =
\begin{itemize}
    \item the set of operation symbols $op : \mathsf{Set} = \{e, +\}$
    \item the arity function $ar : \sigma \rightarrow \mathsf{Set} = \{e \mapsto \mathbf{0}, + \mapsto \mathbb{B}\}$
\end{itemize}

The algebra has the carrier set $\mathbb{N}$ and the evaluation function:

\begin{align*}
\alpha(e) & = 0 \\
\alpha(+, a, b) & = a + b 
\end{align*} 


\end{frame}


\begin{frame}
\frametitle{Universal Algebra}♑

The forgetful functor $\sigma$-Alg to $Set$ admits a left adjoint

This gives us a free $\sigma$-algebra construction on a carrier set

The universal property of a free object:

For any object \( B \) in $\sigma$-Alg and any map between sets \( g : X \to U(B) \),
there exists a unique morphism \( f : F(X) \to B \) in $\sigma$-Alg such that \( g = U(f) \circ \eta \):

% https://q.uiver.app/#q=WzAsMyxbMCwwLCJYIl0sWzIsMCwiVShBKSJdLFsyLDIsIlUoQikiXSxbMCwxLCJpIiwwLHsiY29sb3VyIjpbMSwxMDAsNjBdfSxbMSwxMDAsNjAsMV1dLFswLDIsImciLDJdLFsxLDIsIlUoZikiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XV0=
\[
\begin{tikzcd}[ampersand replacement=\&]
	F(X) \\
	\\
	B
	\arrow["f", dotted, from=1-1, to=3-1]
\end{tikzcd}
\hspace{1cm}
\begin{tikzcd}[ampersand replacement=\&]
	X \&\& {U(F(X))} \\
	\\
	\&\& {U(B)}
	\arrow["\eta", color={rgb,255:red,255;green,54;blue,51}, from=1-1, to=1-3]
	\arrow["g"', from=1-1, to=3-3]
	\arrow["{U(f)}", dotted, from=1-3, to=3-3]
\end{tikzcd}\]

where $U$ is the forgetful functor and $\eta : X \rightarrow F(X)$ is the canonical injection.

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}

We can construct a a free $\sigma$-algebra on $V$ as an inductive type $Tr_\sigma(V)$:
\begin{itemize}
    \item $\text{leaf} : V \rightarrow Tr_\sigma(V)$
    \item $\text{node} : \sum_f(Tr_\sigma(V)^{ar(f)}) \rightarrow Tr_\sigma(V)$
\end{itemize}

node is our evaluation function $\alpha : F_\sigma(Tr_\sigma(V)) \rightarrow Tr_\sigma(V)$

leaf is our canonical injection $\eta : V \rightarrow Tr_\sigma(V)$

This forms a $\sigma$-algebra $\str{T}(V) = (\tree{V}, \term{node})$

By the universal property: $(\blank) \comp \eta \colon \sigAlg(\str{T}(V),\str{X}) \xto{\sim} (V \to X)$

The inverse to the equivalence: the extension operation $\ext{(\blank)}$,
maps $f\colon V \to X$ to a homomorphism $\ext{f}\colon \str{T}(V) \to \str{X}$

\end{frame}

\begin{frame}
\frametitle{Universal Algebra}

An equation signature $\epsilon$ is defined by:
\begin{itemize}
    \item A set of equation symbols $eq : Set$
    \item an arity function for free variables $fv : eq \to Set$
\end{itemize}

We define a system of equation (or a theory $T$) with pairs of trees on the set of free variables:
$l, r : (e : eq) \to Tr_\sigma(fv(e))$

$\mathfrak{X}$ satisfies $T$ ($\mathfrak{X} \entails T$) if for all $e : eq$ and $\rho : fv(e) \to X$,
$\ext{\rho}(l(e)) = \ext{\rho}(r(e))$

Essentially:
\begin{itemize}
    \item $\rho : fv(e) \to X$ maps free variables in equations to elements of $X$
    \item $\ext{\rho} : Tr_\sigma(fv(e)) \to X$ evaluates a tree given some variables
\end{itemize}

\end{frame}

\end{document}
