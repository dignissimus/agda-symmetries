\label{sec:universal-algebra}

As explained above, we can formalize the notion of an unordered list
as the free commutative monoid and the idea of a list as the free
monoid. We can then study sorting as a relationship between these
two structures under the framework of universal algebra~\cite{birkhoffStructureAbstractAlgebras1935}.
However, to begin, we would need to explain what an algebra is,
what exactly is the definition of "free".

\section{Algebra}
First we define very generally what an algebra is. Every algebra
has a signature $\sigma$, which is a (dependent) tuple of:
\begin{itemize}
    \item a set of function symbols $op : \hSet$,
    \item and an arity function $ar : op \to \hSet$.
\end{itemize}

Here, $op$ gives us a set of names to refer to the operations we can do
in an algebra, and the arity function $ar$ specifies the arity of the operation,
using the cardinality of the output set as the arity. In other definitions,
the arity function may be defined as $ar : op \to \Nat$, which specifies
the arity of an operation $op$ by the output natural number. However,
for generality, we decide to use $\hSet$ and cardinality for arity instead,
so that we can have operations of infinite arity. 

\begin{example}
We can define the signature of monoid as follow: the algebra $\Mon$
has operation symbols $\{ e, \mult \}$, referring to the identity operation
and the multiplication operation. The arity function is defined as:
$ar := \{ e \mapsto \Fin[0], \mult \mapsto \Fin[2] \}$.
\end{example}

We use $X^Y$ to denote a vector of $X$ from now on, with the dimension of
the vector given by the cardinality of $Y$. We now can define the type
$F_\sigma(X) := \Sigma_{(f: op)}X^{ar(f)}$, which would be an endofunctor
on $\Set$. We refer to this endofunctor as the signature endofunctor.
In plain English, $F_\sigma(X)$ is a tuple of an operation symbol $op$
and a vector of $X$, where the dimension of the vector is the arity of $op$.

\begin{definition}
    A $\sigma$-structure $\mathfrak{X}$ is an $F_\sigma$-algebra, given by a tuple
    of:
    \begin{itemize}
        \item a carrier set $X : \hSet$,
        \item and an interpretation function $\alpha_X : F_\sigma(X) \to X$.
    \end{itemize}
\end{definition}

In the rest of the dissertation, we use a normal alphabet
(e.g. $X$) to denote the carrier set, and the alphabet in Fraktur font
(e.g. $\mathfrak{X}$) to denote an algebra based on the carrier set.

\begin{example}
($\Nat$, +) is a $\term{Mon}$-algebra, with
the carrier set given by $\Nat$ and its interpretation function given by:
\begin{align*}
    \alpha_X(e) & = 0 \\
    \alpha_X(\mult, [a, b]) & = a + b
\end{align*}
\end{example}

\begin{definition}
    A $F_\sigma$-algebra homomorphism $h: X \rightarrow Y$ is a function such that:
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJGX3tcXHNpZ21hfShYKSJdLFsxLDAsIlgiXSxbMCwxLCJGX3tcXHNpZ21hfShZKSJdLFsxLDEsIlkiXSxbMCwxLCJcXGFscGhhX1giXSxbMCwyLCJGX3tcXHNpZ21hfShoKSIsMl0sWzIsMywiXFxhbHBoYV9ZIiwyXSxbMSwzLCJoIl1d
\[\begin{tikzcd}[ampersand replacement=\&,cramped]
	{F_{\sigma}(X)} \& X \\
	{F_{\sigma}(Y)} \& Y
	\arrow["{\alpha_X}", from=1-1, to=1-2]
	\arrow["{F_{\sigma}(h)}"', from=1-1, to=2-1]
	\arrow["{\alpha_Y}"', from=2-1, to=2-2]
	\arrow["h", from=1-2, to=2-2]
\end{tikzcd}\]
\end{definition}

Informally, this means that for any $n$-ary function symbol $(f, [x_1, \dots, x_n]) : F_{\sigma}(X)$,
\begin{align*}
    h(\alpha_X(f, [a_1, \dots, a_n])) = \alpha_Y(f, [h(x_1), \dots, h(x_n)])
\end{align*}

$F_{\sigma}$-algebras and their morphisms form a category $F_\sigma$-Alg.
For brevity, we also refer to this category as $\sigma$-Alg. The category
is given by the identity homomorphism and composition of homomorphisms.

\section{Free Algebra}
The category $\sigma$-Alg admits a forgetful functor
$\sigma-\term{Alg} \to \Set$, which forgets all the algebraic structure
and only retains the underlying carrier set.
We use $U$ to denote the forgetful functor, and under our notation
$U(\mathfrak{X})$ is simply $X$.

The free $\sigma$-algebra $\mathfrak{F}$ is simply defined as the left adjoint to $U$.
More concretely, it is given by:
\begin{itemize}
    \item a type constructor $F : \Set \to \Set$,
    \item a universal generators map $\eta_X : X \to F(X)$, such that
    \item for any $\sigma$-algebra $\mathfrak{Y}$, post-composition with $\eta_X$ is an equivalence:
\end{itemize}
\[
\begin{tikzcd}[ampersand replacement=\&]
	\mathfrak{F}(X) \\
	\\
	\mathfrak{Y}
	\arrow["f", dotted, from=1-1, to=3-1]
\end{tikzcd}
\mapsto
\begin{tikzcd}[ampersand replacement=\&]
	X \&\& {F(X)} \\
	\\
	\&\& {Y}
	\arrow["\eta_X", color={rgb,255:red,255;green,54;blue,51}, from=1-1, to=1-3]
	\arrow["f \comp \eta_X"', from=1-1, to=3-3]
	\arrow["{f}", dotted, from=1-3, to=3-3]
\end{tikzcd}\]

More concretely, let $f$ be a morphism from $\mathfrak{F}(X) \to \mathfrak{Y}$.
$f$ would be a homomorphism since $\mathfrak{F}(X)$ and $\mathfrak{Y}$ are
objects in the category $\sigma$-Alg. 
We use
$\blank \comp \eta_X : (\mathfrak{F}(X) \to \mathfrak{Y}) \to (X \to Y)$
to denote the act of turning a homomorphism to a set function by
post-composition with $\eta_X$.
The universal property of free algebras state that $\blank \comp \eta_X$
is a equivalence, i.e. there is a one-to-one mapping from
homomorphisms $\mathfrak{F}(X) \to \mathfrak{Y}$ to set functions $X \to Y$.
Naturally, there would be an inverse mapping which maps set functions $X \to Y$
to homomorphisms $\mathfrak{F}(X) \to \mathfrak{Y}$. We refer to this
as the extension operation $\ext{(\blank)} : (X \to Y) \to (\mathfrak{F}(X) \to \mathfrak{Y})$,
and we use $\ext{f}$ to denote a homomorphism given by a set function $f : X \to Y$.

By definition, if $F : \Set \to \Set$ satisfies the universal property of
free $\sigma$-algebra, then $\mathfrak{F}$ would be the free $\sigma$-algebra.
We use "the" to refer to $F$ since $F$ is unique upto isomorphism. 

\subsection{Construction}
We can construct the carrier set of the free $\sigma$-algebra
$\mathfrak{F}(X)$ as an inductive type of trees $Tr_\sigma(V)$:
\begin{code}
data Tree (V : UU) : UU where
    leaf : V -> Tree V
    node : F$_\sigma$(Tree V) -> Tree V
\end{code}

The constructors $leaf$ and $node$ correspond to the generator map
and the interpretation function. Concretely, $Tr_\sigma(V)$ can
be thought of as an abstract syntax tree denoting operations done
an elements of $V$. 