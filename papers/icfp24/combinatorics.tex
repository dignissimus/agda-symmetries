\section{Combinatorics}
\label{sec:combinatorics}

We now explore various combinatorial properties and operations we can define for both
free monoids and free commutative monoids. By univalence and structure identity principle,
everything henceforth holds for any presentation of free monoids and free commutative monoids, 
therefore we avoid naming any specific constructions.
We use $\FF(A)$ to denote the free monoid or free commutative monoid on $A$,
$\LL(A)$ to exclusively denote free monoid and $\MM(A)$ to exclusively denote free commutative monoid.

With universal properties we can structure our programs using ideas from algebra.
For example $\term{length}$ is a common operation defined inductively for $\List$,
but to state properties about $\term{length}$, e.g.
$\term{length}(xs \doubleplus ys) = \term{length}(xs) + \term{length}(ys)$,
we would need to prove them externally. With our framework we can define operations like $\term{length}$
using the $\ext{(\blank)}$ operation, which would also give us a proof that they are homomorphisms for free.
We can also use universal property to prove two different types are equal by showing they both
satisfy the same universal property, which is desirable especially if proving a direct equivalence between
the two types is very difficult.

To illustrate this, we give some examples of how some common operations can be defined
in terms of universal property.

\subsection{Length}

Any presentation of free monoids or free commutative monoids has a $\term{length} : \FF(A) \to \Nat$ function.
$\Nat$ is a (commutative) monoid with $(0,+)$, so we can extend $\lambda x.\, 1\,:\,A \to \Nat$.
This allows us to define $\term{length}$ for any construction of free (commutative) monoid, and also
gives us a proof of $\term{length}$ being a homomorphism for free.

\begin{figure}[H]
    \centering
    \begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\FF(A)} \&\& {(\mathbb{N}, 0, +)} \\
    	\\
    	A
    	\arrow["\eta_A", from=3-1, to=1-1]
    	\arrow["{\ext{(\lambda x. \, 1)}}", from=1-1, to=1-3]
    	\arrow["{\lambda x. \, 1}"', from=3-1, to=1-3]
    \end{tikzcd}
    \caption{Definition of $\term{length}$ by universal property}
    \label{fig:enter-label}
\end{figure}


\subsection{Membership}\label{comb:member}
Any presentation of free monoids or free commutative monoids has a membership predicate:
$\_\in\_ : A \to \FF(A) \to \hProp$. By fixing an element $x: A$, the element we want to define
the membership proof for, and 
assuming $A$ is a set, we can define $\yo_A(x) = \lambda y.\, x \id y : A \to \hProp$.
Since $\hProp$ forms a (commutative) monoid under $\vee$,
we can extend $\yo_A(x)$ to obtain $x \in \blank : \FF(A) \to \hProp$, giving us the membership predicate for $x$.

\begin{figure}[H]
    \centering
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXEZGKEEpIl0sWzIsMF0sWzAsMiwiQSJdLFszLDAsIihcXGhQcm9wLCBcXGJvdCwgXFx2ZWUpIl0sWzIsMCwiXFxldGFfQSJdLFswLDMsIih4IFxcaW4gXFxibGFuaykgLyBcXGV4dHtcXHlvX0EoeCl9Il0sWzIsMywiXFx5b19BKHgpIiwyXV0=
    \begin{tikzcd}[ampersand replacement=\&,cramped]
    	{\FF(A)} \&\& {} \& {(\hProp, \bot, \vee)} \\
    	\\
    	A
    	\arrow["{\eta_A}", from=3-1, to=1-1]
    	\arrow["{(x \in \blank) / \ext{\yo_A(x)}}", from=1-1, to=1-4]
    	\arrow["{\yo_A(x)}"', from=3-1, to=1-4]
    \end{tikzcd}
    \caption{Definition of membership proof for $x$ by universal property}
    \label{fig:enter-label}
\end{figure}


\subsection{Any and All predicate}

Any presentation of free monoids or free commutative monoids $\FF(A)$ has the
$\term{Any}$ and $\term{All}$ predicates, which allow us to lift a predicate $A \to \hProp$
to any or all elements of $xs : \FF(A)$. We note that
$\hProp$ forms a (commutative) monoid in two different ways: $(\bot,\vee)$ and $(\top,\wedge)$,
therefore given a predicate $P : A \to \hProp$, we get:
\begin{align*}
    Any(P) &= \ext{P} : \FF(A) \to (\hProp, \bot, \vee) \\
    All(P) &= \ext{P} : \FF(A) \to (\hProp, \top, \wedge)
\end{align*}

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.49\textwidth}
        \centering
        \begin{tikzcd}[ampersand replacement=\&,cramped]
        	{\FF(A)} \&\& {(\hProp, \top, \wedge)} \\
        	\\
        	A
        	\arrow["\eta_A", from=3-1, to=1-1]
        	\arrow["{\ext{P}}", from=1-1, to=1-3]
        	\arrow["{P}"', from=3-1, to=1-3]
        \end{tikzcd}
        \caption{Definition of $\term{All}$ by universal property}
        \label{fig:enter-label}
    \end{minipage}
    \begin{minipage}[t]{0.49\textwidth}
        \centering
        \begin{tikzcd}[ampersand replacement=\&,cramped]
        	{\FF(A)} \&\& {(\hProp, \bot, \vee)} \\
        	\\
        	A
        	\arrow["\eta_A", from=3-1, to=1-1]
        	\arrow["{\ext{P}}", from=1-1, to=1-3]
        	\arrow["{P}"', from=3-1, to=1-3]
        \end{tikzcd}
        \caption{Definition of $\term{Any}$ by universal property}
        \label{fig:enter-label}
    \end{minipage}
\end{figure}

\subsection{Other properties}
Free commutative monoid and free monoids also share some common properties,
for example both are conical~\cite{wehrungTensorProductsStructures1996}. However, more often than not,
they exhibit different properties. For example, only free commutative monoid exhibits
the property of mapping coproduct monoidal structure to product monoidal structure:
i.e. $\MM(A) \times \MM(B) = \MM(A + B)$, and other properties such
as Riesz refinement property~\cite{dobbertinRefinementMonoidsVaught1983}. We
refer the reader to~\cite{choudhuryFreeCommutativeMonoids2023} for these proofs.

\subsection{Head}\label{sec:head}
More generally, commutativity is a way of enforcing unordering, or forgetting ordering,
and by constructing a function from $\MM(A)$ to a structure which is not commutative,
we must impose some kind of ordering in order to define such a function.

Consider the $\term{head} : \FF(A) \to A$ function which takes an element out of $\FF(A)$.
We consider by cases on the length of $\FF(A)$.

Case 0: $\term{head}$ cannot be defined, for example if $A = \emptyt$, such a function would lead to
a contradiction.

Case 1: $\term{head}$ can be defined for both $\MM(A)$ and $\LL(A)$. In fact, it is a equivalence
if we only consider $xs : \FF(A)$ where $\term{length}(xs) = 1$, with its inverse given by $\eta_A$.

Case $n \geq 2$: $\term{head}$ can be defined for any $\LL(A)$. Using $\List$ as an example, one can simply
take the first element of the list. However, for $\MM(A)$, $\term{head}$ can only be defined if it
respects commutativity. Using $\SList$ as an example, this means $\term{head}$ must satisfy:
$\term{head}(x :: y :: xs) = \term{head}(y :: x :: xs)$ for any $x, y : A$ and $xs : \SList(A)$.
This implies if we were to define $\term{head}$ for $\MM(A)$, we must be able to order or sort a
list $xs$ of $A$ somehow, so we can pick a "least" or "biggest" element $x \in xs$ such that for any
permutation of $xs$ $xs^*$, $\term{head}(xs^*) = x$.
