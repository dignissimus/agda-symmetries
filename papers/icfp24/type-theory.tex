\section{Notation}\label{sec:notation}
As we have explained, our work is formalized in Cubical Agda and Cubical Type Theory,
which is a variant of Homotopy Type Theory that is designed to preserve
computational properties of type theory.
We refer the readers to other works such as~\cite{vezzosiCubicalAgdaDependently2019}
and~\cite{cohenCubicalTypeTheory2018} for a more in-depth explanation on Cubical Type Theory
and how we can program in Cubical Agda. We give a quick overview of the type
theory notation in use in this paper.

We denote the type of types with $\mathcal{U}$. 
In practice, $\mathcal{U}$ would be indexed by a type level 
Ã  la Russell for consistency, however we opted to omit the type level
for simplicity and clarity.
We use $\Fin[n]$ to denote finite sets of cardinality $n$ in HoTT~\cite{yorgeyCombinatorialSpeciesLabelled2014a}.
This is defined as follow:
\vspace{-1em}
\begin{code}
Fin : $\mathbb{N}$ -> UU
Fin n = $\Sigma$[ m $\in$ $\mathbb{N}$ ] (m < n)
\end{code}

\noindent
There are multiple ways to define $\Fin$, one example being an indexed inductive type,
for example:
\vspace{-1em}
\begin{code}
data Fin : $\mathbb{N}$ -> UU where
    fzero : $\forall$ {n : $\mathbb{N}$} -> Fin (fsuc n)
    fsuc  : $\forall$ {n : $\mathbb{N}$} -> Fin n -> Fin (fsuc n)
\end{code}
In our construction we opted to use this definition because cubical Agda does not behave well
when pattern matching on indexed inductive types.

We also use $\times$ to denote product types and $+$ to denote coproduct types.
For mere propositions, we use $\land$ to denote logical and, and $\vee$ to denote logical or.
In Cubical Agda these are defined as propositionally-truncated products and coproducts.